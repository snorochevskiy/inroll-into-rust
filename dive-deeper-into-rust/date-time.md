---
hidden: true
---

# Дата и время

## Таймеры

В стандартной библиотеке Rust отсутствует функциональность для работы с датами и астрономическим временем, но имеются следующие три типа:

* [std::time::Duration](https://doc.rust-lang.org/stable/std/time/struct.Duration.html) — представляет собой временной временной отрезок.\
  Например: 5 секунд, 3 минуты, 1 час.
* [std::time::SystemTime](https://doc.rust-lang.org/std/time/struct.SystemTime.html) — API для работы с системным таймером.
* [std::time::Instant](https://doc.rust-lang.org/std/time/struct.Instant.html) — API для работы с монотонным таймером.

Системный таймер хранит астрономическое время. Если мы хотим получить текущее Unix время (количество секунд, прошедшее с 1 января 1970 года), то мы должны использовать как раз системный таймер.

```rust
use std::time::{Duration, SystemTime};

fn main() {
    let sys_time_now = SystemTime::now();
    let unix_time_duration: Duration =
            sys_time_now.duration_since(SystemTime::UNIX_EPOCH).unwrap();
    let unix_time_now: u64 = unix_time_duration.as_secs();
}
```

Однако у системного таймера есть проблема: если запросить текущее время у системного таймер, а после сразу запросить его еще раз, то есть вероятность, что время полученное для второго запроса будет раньше, чем у первого. Почему так происходит — отдельная история, но главное что нам нужно знать, как прикладным программистам: не следует использовать системный таймер для того, чтобы замерять время выполнения участка кода.

Монотонный таймер хранит не астрономическое время, а время прошедшее с момента текущего старта запуска. При этом, монотонный таймер гарантирует, что каждый последующий запрос текущего времени будет выдавать значение не меньшее, чем выдал предыдущий запрос. Очевидно, что монотонный таймер используется как раз для замера времени выполнения участков кода.

```rust
use std::time::{Duration, Instant};

fn main() {
    let start = Instant::now();
    //... какая-то функциональность
    let took: Duration = start.elapsed();
}
```

## chrono
