# Функции

Как и в других языках программирования, в Rust функции — это механизм, позволяющий разбить программу, на отдельные гранулированные подпрограммы.

Синтаксис объявления функции:

```rust
fn func_name(arg1: Тип1, arg2: Тип2) -> ТипВозвращаемогоЗначения {
    тело функции
}
```

Пример:

```rust
fn sum(a: i32, b: i32) -> i32 {
    a + b
}

fn safe_divide(a: f32, b: f32) -> f32 {
    if b != 0.0 {
        a / b
    } else {
        0.0
    }
}

fn main() {
    let a = sum(1, 2);
    println!("{a}");
    
    let b = safe_divide(12.0, 4.0);
    println!("{b}");
}
```

При объявлении аргументов функции, можно вставлять запятую после последнего аргумента, и поведение будет таким же, как и без неё.

```rust
fn sum(a: i32, b: i32,) -> i32 { .. }
```

## return

Как мы видим, последнее вычисленное значение автоматически является результатом функции.

При необходимости "досрочно" выйти из функции, следует явно использовать оператор `return`:

```rust
fn safe_divide(a: f32, b: f32) -> f32 {
    if b == 0.0 {
        return 0.0;
    }
    a / b
}
```

## Функции внутри функций

Rust позволяет объявлять функцию внутри другой функции.

Если часть функциональности функции хорошо гранулирована, и используется несколько раз, и при этом не нужна больше нигде в программе, то её можно вынести в отдельную внутреннюю функцию.

```rust
// Возвращает i-й элемент последовательности Фибоначчи.
// Индексация элементов последовательности - с нуля.
fn fibonacci_nth_element(index: usize) -> u32 {
    if index == 0 {
        return 0;
    }
    if index == 1 {
        return 1;
    }
    // Высчитывет i-й элемент последовательности Фибоначчи
    // * x0            - i-й элемент последовательности
    // * x1            - (i+1)-й элемент последовательности
    // * next_index    - индекс следующего (i+2) элемента
    // * desired_index - индекс искомого элемента
    fn next_fibonacci(x0: u32, x1: u32, next_index: usize, desired_index: usize) -> u32 {
        let x2 = x0 + x1;
        if next_index == desired_index {
            x2
        } else {
            next_fibonacci(x1, x2, next_index + 1, desired_index)
        }
    }

    next_fibonacci(0, 1, 2, index)
}

fn main() {
    println!("{}", fibonacci_nth_element(0)); // 0
    println!("{}", fibonacci_nth_element(1)); // 1
    println!("{}", fibonacci_nth_element(2)); // 1
    println!("{}", fibonacci_nth_element(3)); // 2
    println!("{}", fibonacci_nth_element(4)); // 3
}
```

## return и never type

{% hint style="info" %}
Приведённая ниже информация не является необходимой для программировании на Rust, а скорее просто даёт лучшее понимание системы типов.
{% endhint %}

В главе [primitive-types.md](primitive-types.md "mention") мы уже упоминали never type `!`, который используется для выражений, которые не возвращают управление в вызывающий код.

Never type не представляет каких-то реальных данных, а просто играет роль заглушки, чтобы "склеить" воедино систему типов Rust.

Тип возвращаемый оператором `return` —  `!`,  что логично, так как `return` не возвращает управление в функцию, в которой он находится, а выходит из функции в то место, откуда функция была вызвана.

```rust
fn gen_num() -> i32 {
    // Переменная v имеет тип !
    let v = return 5;
}
  
fn main() {
    let a = gen_num();
}
```

## const функции

В Rust можно задать функцию, которая может быть выполнена на этапе компиляции. Такая функция отмечается ключевым словом `const`.

```rust
const fn func_name(arg1: Тип1, arg2: Тип2) -> ТипВозвращаемогоЗначения {
    тело функции
}
```

Например:

```rust
const PI: f32 = 3.14;
const TAU: f32 = double(PI);

const fn double(num: f32) -> f32 {
    num * 2.0
}

fn main() {
    println!("Tau = {TAU}");
}
```

## static переменные

Функция может содержать [статические переменные](variables.md#static), значения которых сохраняются между вызовами функций.

Это проще показать на примере.

```rust
fn sum_with_previous(x: i32) -> i32 {
    static mut PREV: i32 = 0; // статическая переменная
    unsafe {
        let result = PREV + x;
        PREV = x;
        result
    }
}

fn main() {
    println!("{}", sum_with_previous(1));  // 1
    println!("{}", sum_with_previous(2));  // 3
    println!("{}", sum_with_previous(7));  // 9
    println!("{}", sum_with_previous(-6)); // 1
}
```

Функция `sum_with_previous` складывает значение аргумента со значением аргумента из своего предыдущего вызова. Для этого она использует статическую переменную `PREV`, которая живёт вне контекста вызова функции.

Как видно, `PREV` инициализруется нулём. Эта инициализация выполняется только для первого вызова функции.

Так же хочется отметить, что всё взаимодействие с мутабельной статической переменной может выполняться только внутри блока `unsafe`. Дело в том, что потенциально эта функция может быть одновременно вызвана из нескольких параллельных потоков, что может привести к сохранению или чтению некорректного значения PREV одним из потоков. Это классически пример гонок данных (data race), что в безопасном Rust недопустимо. Именно поэтому небходим `unsafe` блок.

Это первый раз, когда мы сталкиваемся с блоком `unsafe`. Мы еще познакомимся с ним подробнее, а пока что скажем, что вся ответственность за безопасность кода внутри блока `unsafe` ложится на плечи его автора. Поэтому стоит избегать использования небезопасного Rust, если в этом нет необходимости.

Как вы могли понять, мутабельные статические переменные не особо безопасны по своей природе, и могут быть использованы без дополнительных механизмов синхронизации только в однопоточной среде. К счастью, в back-end приложениях вы скорее всего никогда не будете их использовать: мы рассмотрели их только для того, чтобы больше раскрыть тему функий.
