# Вектор

Как мы уже знаем, размер массива должен быть известен во время компиляции, что делает его бесполезным для сценариев, при которых размер вычисляется в процессе работы программы.

Тип `Vec` (вектор), представляет из себя непрерывную последовательность элементов, размер которой может определяться и изменяться во время выполнения программы.

{% hint style="info" %}
`Vec<T>` является обобщённой (generic) структурой. И генерики, и структуры мы изучим только несколько глав спустя, однако, вектор является настолько вездесущей стуруктурой данных, что изучать даже базовые конструкции Rust без него будет очень сложно. Поэтому, на данном этапе мы только разберёмся как с ним работать, и как он располагается в памяти.\
Если же вы знакомы с C++, то вы уже, скорее всего, провели аналогию с шаблонным классом `std::vector`, и оказались полностью правы.\
Если Вы знакомы с Java, то считайте вектор близким родственником класс `ArrayList<T>`.
{% endhint %}

Для начала, рассмотрим пример использования вектора:

{% code lineNumbers="true" %}
```rust
fn main() {
  let mut my_vec: Vec<i32> = Vec::new();

  my_vec.push(1);
  my_vec.push(2);
  my_vec.push(3);

  let third: i32 = my_vec[2];
  println!("3-rd element: {}", third);
}
```
{% endcode %}

Здесь мы в строке (2) создаём пустой вектор, который будет хранить элементы числового типа `i32`.\
Далее, в строках (4,5,6) мы помещаем в вектор числа 1, 2 и 3.\
Под конец, в строке (8) мы объявляем переменную `trird`  и присваиваем ей третий элемент вектора (индексация элементов в векторе, как и в массиве, начинается с нуля).

Как видно, с точки зрения использования, вектор можно рассматривать просто, как динамически расширяемый массив.

## Лэйат в памяти

Теперь поговорим о том, как вектор хранится в памяти. Когда мы создаём переменную вектора, то на стеке располагается только его "служебная ифнормация", а сами данные хранятся в куче - в буфере, который вектор для себя аллоцирует в момент своего создания. На стеке хранятся такие 3 поля:

* указатель на начало буфера в куче — в этом буфере хранятся сами элементы вектора
* счётчик количества элементов, записанных в буфере в куче
* размер буфера в куче

Лэйаут (layout) в памяти для вектора, из примера выше, выглядит так:

<img src="../.gitbook/assets/file.excalidraw (7).svg" alt="Vec<i32> memory layout" class="gitbook-drawing">

Размер по умолчанию для буфера в куче, который вектор изначально создаёт не стандартизирован, но да данной диаграмме мы предположили, что он равен 5.

Если на момент создания вектора известен желаемый размер буфера в хипе, то его можно задать явно заменив `Vec::new()`  на `Vec::with_capacity(размер)`. Это приведёт к тому, что вектор аллоцирует первичный буфер в куче ровно такого размера, чтобы иметь возможность вмести ровно заданное количество элементов.

При добавлении элементов в вектор, счётчик элементов в буфере (len) увеличивается, пока не достигнет максимального размера буфера (capacity). Когда буфер будет полностью заполнен, вектор аллоцирует новый буфер большего размера, скопирует в него все элементы из старого буфера, после чего старый буфер будет удалён. Добавление элементов продолжится уже в новый буфер.

### Макрос vec!

Создавать вектор путем, сначала объявления пустого вектора, а следом добавления в него элементов по одному, выглядит многословным. Поэтому, учитывая, что вектор является найболее часто используемой структурой данных, в стандартную библиотеку Rust включили специальный макрос `vec![]`, который берёт на себя бремя поэлементного добавления элементов в вектор.

При помощи этого макроса, мы можем переписать пример выше таким образом:

```rust
fn main() {
  let mut my_vec = vec![1,2,3];

  let third: i32 = my_vec[2];
  println!("3-rd element: {}", third);
}
```

Как работает этот макрос станет понятно только после прочтения главы [deklarativnye-makrosy.md](deklarativnye-makrosy.md "mention"), однако принцип его использования должен быть понятен уже сейчас: макрос просто раскрывается компилятором в код, который сначала создаёт пустой вектор, а далее заталкивает в него элементы по одному, так же, как мы делали это без макроса.
