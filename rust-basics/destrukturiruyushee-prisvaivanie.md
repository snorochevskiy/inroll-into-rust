# Деструктурирующее присваивание

В главе [tuples.md](tuples.md "mention"), мы познакомились со специальным синтаксисом для "разбиения" объекта кортежа на его составляющие.

```rust
let employee: (&str, i32, bool) = ("John Doe", 1980, true);
let (name, birth_year, is_active_employee) = employee;
```

Такая операция "разбиения" объекта на составляющие называется деструктурирующим присваиванием.

Деструктурирующее присваивание доступно не только для кортежей, но так же для массивов и структур. Рассмотрим нескольк примеров.

## Кортежи

С деструктурированим кортежей мы уже знакомы, однако давайте взглянем на более сложный пример с вложенным кортежем.

```rust
let tup: (i32,char,bool,(i32,i32,i32)) = (1, 'z', true, (7,7,7));
let (num, c, _, t) = tup;
println!("num={}, char={}, triplet={:?}", num, c, t);
```

Здесь мы присвоили весь вложенный кортеж целиком в переменную `t`, однако мы можем деструктурировать и вложенный кортеж.

```rust
let tup: (i32,char,bool,(i32,i32,i32)) = (1, 'z', true, (7,8,9));
let (num, c, _, (d1, d2, d3)) = tup;
println!("num={num}, char={c}, d1={d1}, d2= {d2}, d3={d3}");
```

Обратите внимание, что для элемента, знаение которого нам не интересно, мы использовали "выброшенную" (discarded) переменную.

## Массивы

Массивы так же можно деструктурировать.

```rust
let arr: [i32;3] = [1, 2, 3];
let [a1, a2, a3] = arr;
println!("a1={a1}, a2={a2}, a3={a3}");
```

При деструктурировании массива, можно часть элементов, идущих с начала массива, присвоить переменным, а оставшиеся элементы (в хвосте массива) проигнорировать.

```rust
let arr: [i32;5] = [1, 2, 3, 4, 5];
let [a_1, _, a_3, ..] = arr;
println!("a1={}, a3={}", a_1, a_3);
```

Так же, оставшиеся элементы в хвосте массива можно не игнорировать, а записать в новый массив:

```rust
let arr: [i32;5] = [1, 2, 3, 4, 5];
let [a_1, _, a_3, rest @ ..] = arr;
// Тип переменной rest - массив [i32, 2]
println!("a1={}, a3={}, rest={:?}", a_1, a_3, rest);
```

Выражение `rest@..` означает: привязать все остальные элементы к переменной `rest`.

Мы не можем совершить деструктурирующее присваивание для слайсов или векторов, так как компилятор не может гарантировать соответствие количества переменных в деструктурирующем шаблоне с количеством элекментов в слайсе. Массив же, в отличии от слайсов, имеет фиксированный размер известный еще на стадии компиляции.

## Структуры

Аналогично тому, как кортежи диструктурируются исходя из позиции элементов, структуры диструктурируются исходя из имён полей.

```rust
struct Person { name: String, age: u32 }

fn main() {
    let p = Person { name: String::from("John"), age: 25 };
    let Person { name, age } = p;
    println!("Name={}, Age={}", name, age);
}
```

При деструктурировании структуры мы так же можем "извлечь" только те поля, которые нам нужны:

```rust
struct Person { name: String, age: u32 }

fn main() {
    let p = Person { name: String::from("John"), age: 25 };
    let Person { name, .. } = p;
    println!("Name={name}");
}
```
