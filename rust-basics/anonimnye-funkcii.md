# Анонимные функции

Rust испытал на себе определённое влияние функционального программирования, поэтому имеет поддержку анонимных функций, замыканий и функций высшего порядка.

## Анонимные функции

Анонимная функция — функция, являющаяяся объектом, который можно присвоить переменной, передать в качестве аргумента в другую функцию, и, разумеется, вызвать.

Анонимные функции декларируются при помощи синтаксиса, так называемого, функционального литерала:

```
|аргумент_1, …, аргумент_n| -> ТипРезультата { тело фунции }
```

Например:

{% code lineNumbers="true" %}
```rust
fn main() {
    let inc: fn(i32) -> i32 = |x: i32| { x + 1 };
    let a = 1;
    let b = inc(a);
    println!("{b}"); // 2
}
```
{% endcode %}

Здесь мы в строке (2) создаём анонимную функцию, и присваиваем её переменной `inc`. Далее в строке (4) мы вызываем нашу функцию абсолютно так же, как и обычную.

Обратите внимание, что тип анонимной функции выглядит как:

```rust
fn(тип_аргумента_1, ..., тип_аргумента_2) -> тип_результата
```

Такой тип называется **указателем на функцию** (function pointer).

Как и с обычными переменными, тип анонимной функции можно не указывать, если компилятор в состоянии вывести его по телу анонимной функции.

```rust
let inc = |x: i32| { x + 1 };
```

Так же, фигурные скобки вокруг тела анонимной функции не обязательны, если оно состоит только из одного выражения:

```rust
let inc = |x: i32| x + 1;
```

В некоторых ситуациях компилятор способен вывести типы аргументов, и тогда их тоже можно опустить.

{% hint style="info" %}
Часто анонимные функции называют лямбда-выражениями, отсылаясь к разделу математики "Лямбда-исчисление", которое легло в основу функционального программирования. Так же анонимные функции часто называют лямбда-функциями.
{% endhint %}

## Функции высшего порядка

Функцей высшего порядка называют функции, которые принимают другие функции в качестве аргумента, либо возвращают функци, как результат.

Для примера напишем функцию вышего порядка `transform`, которая принимает два аргумента: число, и функцию; и возвращает результат применения этой функции к числу:

```rust
fn transform(a: i32, f: fn(i32) -> i32) -> i32 {
    f(a)
}

fn main() {
    let inc: fn(i32) -> i32 = |x: i32| { x + 1 };
    let a = 9;
    let b = transform(a, inc);
    println!("{b}"); // 10
}
```

Теперь рассмотрим пример, когда функция возвращает анонимную функцию в качестве результата:

```rust
fn create_inc() -> fn(i32) -> i32 {
    |x: i32| x + 1 
}

fn main() {
    let inc = create_inc();
    let a = 1;
    let b = inc(a);
    println!("{b}"); // 2
}
```

## Указатель на функцию

Анонимные функци компилируются таким же образом как и обычные, и помещаются в сегмент кода. Когда мы присваиваем анонимную функцию переменной, то в переменую просто записывается указатель на функцию.

В таком случае, чем же анонимная функция приниципиально отличается от обычной уровне исполняемого кода? Ничем. Более того, указатель на обычную функцию можно точно так же присвоить переменной.

```rust
fn func_inc(x: i32) -> i32 {
    x + 1
}

fn main() {
    let inc: fn(i32) -> i32 = func_inc;
    let a = inc(7);
    println!("{a}"); // 8
}
```

Как мы видим, анонимные функции — это просто другой синтаксис для создания функций.

## Замыкание

В примере выше мы сделали функцию `create_inc`, которая возвращает анонимную функцию — инкретмент:

```rust
fn create_inc() -> fn(i32) -> i32 {
    |x: i32| x + 1 
}
```

Теперь давайте попробуем написать функцию, которая возвращает анонимную функцию, которая увеличивает свой аргумент не на единицу, а на заданный шаг:

```rust
fn make_inc_with_step(step: i32) -> fn(i32) -> i32 {
	|x| { x + step }
}
```

Увы, такой код не скомпилируется, и выдаст ошибку:

```
|x| { x + step }
^^^^^^^^^^^^^^^^ expected fn pointer, found closure
```

Дело в том, что из тела нашей анонимной функции, мы обращаемся к данным, которые принадлежат скоупу за пределами функции. Такая анонимная функция называется **замыканием** (потому что она как бы замкнута на свой внешний скоуп). Говорят, что замыкание "захватывает" данные из внешнего контекста.

Замыкания, по своей природе, гораздо сложнее "чистых" анонимных функций (которые зависят только от своих аргументов). Чистая анонимная функция просто превращается в обычную функцию в сегменте кода, и мы работаем с ней через указатель на функцию. Замыкание же — это объект, представляющий из себя сложную комбинацию кода и захваченных данных.

Давайте сначала перепишем код так, чтобы он работал, а потом будем его разбирать.

{% code lineNumbers="true" %}
```rust
fn make_inc_with_step(step: i32) -> impl Fn(i32) -> i32 {
    move |x| { x + step }
}

fn main() {
    let inc_with_5 = make_inc_with_step(5);
    let a = inc_with_5(2);
    println!("{a}"); // 7
}
```
{% endcode %}

Как видим, у нас здесь два отличия:

* `fn(i32)->i32` превратилось в `impl Fn(i32)->i32`, что явно указывает на то, что замыкание — это не просто указатель на функцию, а объект некого типа, который реализует трэйт `Fn`.
* Перед объявлением функционального литерала появилось ключевое слово **move**, которым мы явно указываем для компилятора, что если мы внутри замыкания используем какое-то значение из внешнего контекста, то владение над этим значением перемещается к замыканию.

## Типы замыканий

Как мы уже сказали, для всех анонимных функций, используется один типа данных — указатель на функцию, который имеет вид `fn(...)->...`. Вернее, сами типы отличаются, но все они объединены в семейство указателей на функции. Для замыканий же есть три разных трэйта:

* [**Fn**](https://doc.rust-lang.org/std/ops/trait.Fn.html) — трэйт для замыканий, которые захватывают значения из внешнего контекста по значению, либо по немутабельной ссылке. Такие замыкания безопасно использовать в многопоточной среде, так как они только читают захваченное значение.
* [**FnMut**](https://doc.rust-lang.org/std/ops/trait.FnMut.html) — трэйт для замыканий, которые захватывают значения из внешнего контекста, и изменяют его по мутабельной ссылке.  Такие замыкания нельзя использовать в многопоточной среде без предварительной синхронизации, так как они могут менять захваченное значение.
* [**FnOnce**](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) — трэйт для замыканий, которые захватывают значения из внешнего контекста по значению (т.е. берут над ним владение), и уничтожают этот объект в процессе своего вызова. Такое замыкание можно вызвать только один раз, так как после первого вызова значение будет уничтожено и недоступно для второго вызова.

## Захват по ссылке и перемещение владения

Как мы сказали выше, замыкание может захватывать значения из внешнего констекста по значению или по ссылке. От того каким образом захваченное значение будет использовано в теле замыкания, будет зависеть то, на основе какого трэйта компилятор сгенерирует тип замыкания: `Fn`, `FnMu`t или `FnOnce`.

Рассмотрим самый простой пример захвата по немутабельной ссылке.

```rust
fn main() {
    let salutation = "Hello".to_string();

    // Тип замыкания: impl Fn(&str)->String
    let greet = |name: &str| make_greeting(&salutation, name);

    println!("{}", greet("John")); // Hello John

    // Переменная salutation захвачена замыканием по немутабельной ссылке,
    // поэтому всё еще может быть использована после захвата.
    print_string(salutation); // OK, data is still usable
}

fn make_greeting(salutation: &str, name: &str) -> String {
    format!("{} {}", &salutation, name)
}

fn print_string(s: String) {
    println!("{s}")
}
```

Захват значения переменной `salutation` произошло по немутабельной ссылке, потому что в теле самого замыкания мы используем немутабельную ссылку `&salutation` .

{% hint style="info" %}
Нам пришлось создать отдельные функцию `make_greeting` и `print_string`, чтобы по их сигнатурам было явно видно какие аргументы используются по ссылке, а какие по значению. Использование макросов `format!` и `println!` напрямую нарушило бы чистоту эксперимента, так как эти макросы используют объекты строк по ссылке, даже если их явно передать по значению.
{% endhint %}

Если же в теле замыкания, мы используем по значению переменную, захваченную из внешнего контекста, то и захват произойдёт по значению.

```rust
fn main() {
    let salutation = "Hello".to_string();

    // Тип замыкания: impl Fn(&str)->String
    let greet = |name: &str| make_greeting(salutation, name);

    println!("{}", greet("John")); // Hello John

    // Теперь когда salutation захвачена по значению,
    // т.е. перемещена в замыкание использовать её нельзя
    // print_string(salutation); // Error: use of moved value: `salutation`
}

fn make_greeting(salutation: String, name: &str) -> String {
    format!("{} {}", &salutation, name)
}

fn print_string(s: String) {
    println!("{s}")
}
```

Почему в предудущих примерах не было `move`? Дело в том, что `move` нужно явно указывать  только если замыкание живёт дольше скоупа в котором оно создано. В нашем простом примере, компилятор способен сам однозначно разобраться какое поведение ожидается. Но если мы попытаемся вынести создание замыкания `greet` в отдельную функцию, то `move` понадобится:

```rust
fn make_greet_closure() -> impl Fn(&str) -> String {
    let salutation = "Hello".to_string();
    move |name: &str| make_greeting(&salutation, name)
}
```

Здесь наше замыкание живёт дольше чем скоуп, в котором оно создано: скоуп (тело функции `make_greet_closure`) завершается, а замыкание продолжает жить в коде, который вызвал фунцию `make_greet_closure`.

## FnMut

Как мы уже сказали, если замыкание захватывает значение по мутабельной ссылке, то компилятор делает такое замыкание реализацией трэйта `FnMut`.

Для примера, напишем еще одно инкрементирующее замыкание, однако теперь замыкание будет иметь ссылку на число, которое хранит шаг инкретмента.  После каждого вызова этот шаг инкремента будет увеличивать на единицу.

```rust
fn main() {
    let mut step = 1;

    // impl FnMut(i32)->i32
    let mut growing_inc = |x: i32| {
        let step_ref = &mut step;
        let res = x + *step_ref;
        *step_ref += 1;
        res
    };
    println!("{}", growing_inc(1)); // 2
    println!("{}", growing_inc(1)); // 3
    println!("{}", growing_inc(1)); // 4
}
```

Важно напомнить, что тип замыкания зависит не от того, как значение захвачего из внешнего скоупа, а от того как это захваченное значение используется.

Замыкание, из примера выше, имеет тип основанный на `FnMut` не потому что оно захватывает значение по мутабельной ссылке, а потому что оно по мутабельной ссылке изменяет значение, чьё время жизни больше чем один вызов замыкания.

Рассмотрим этот же пример, но только теперь наше замыкание захватит переменную `step` не по мутабельной ссылке, а по значению.

```rust
fn main() {
    let mut step = 1;

    // impl FnMut(i32)->i32
    let mut growing_inc = |x: i32| {
        let res = x + step;
        step += 1;
        res
    };
    println!("{}", growing_inc(1)); // 2
    println!("{}", growing_inc(1)); // 3
    println!("{}", growing_inc(1)); // 4
}
```

Это замыкание всё еще увеличивает шаг инкремента после каждого своего вызова, и тип замыкания всё еще реализует трэйт `FnMut`. Почему так? Как мы сказали: не важно как замыкание захватило значение, важно то, как оно это значение изменяет.

Замыкание захватило переменную `step` по значению, и поместило в свой контекст, где это значение сущестует вне вызовов самого замыкания. А при вызове, замыкание изменяет это значение по мутабельной ссылке.

## FnOnce

После того как мы делально рассмотрели `Fn` и `FnMut`, разобраться с `FnOnce` должно быть несложно. Главное помнить, что тип замыкания зависит от того, что замыкание делает с захваченным значением: `Fn` замыкания только читают захвачееное значение, `FnMut` изменяют его по мутабельной ссылке. `FnOnce` же захваченное значение значение уничтожает.

Рассмотрим следующий пример:

```rust
// Обёртка над println!(), которая принимает строку по значению,
// следовательно забирает её себе из вызывающего кода
fn print_and_destroy(s: String) {
    println!("{s}");
}

fn main() {
    let text = "text".to_string();
    // Тип замыкания: FnOnce()
    let print_and_destory_text = || print_and_destroy(text);
    print_and_destory_text();
}
```

Если попытаться вызвать `print_and_destory_text()` во второй раз, то компилятор выдаст ошибку: closure cannot be invoked more than once because it moves the variable `text` out of its environment.

Этот тип замыканий часто используется, когда замыкание захватывает какой-то ресурс, операция над которым имеет побочный эффект: закрытие файла, очистка памяти, и другие операции, которые можно сделать только один раз.

## Конкретный тип замыкания

В коде программы мы не имеем доступ к конкретному типу замыкания, потому что этот конкретный тип будет сгенерирован только при компиляции.

То есть мы не можем написать:

```rust
fn make_inc_with_step(step: i32) -> impl Fn(i32) -> i32 {
    move |x| { x + step }
}

fn main() {
    let inc_with_5: Какой-то тип = make_inc_with_step(5);
}
```

Единственное, что мы можем знать о тип замыкания, это то какой трэйт он реализует, и какая у замыкания сигнатура (типы агрументов и возвращаемого значения).

{% hint style="info" %}
В ночной сборке Rust при помощи флага `type_alias_impl_trait` можно включить псевдонимы для impl Трэйтов. Тогда можно будет писать так:

```rust
type MyFn = impl Fn(i32) -> i32;
let inc_with_5: MyFn = make_inc_with_step(5);
```

На момент выхода Rust 1.89, эта фича всё еще не была доступна в стабильной ветке.
{% endhint %}

Так же очень важно знать, что в программе на Rust нет двух замыканий с одинаковыми типами. Даже если у двух замыканий совпадает сигнатура и трэйт, который они реализуют, конкретные типы, которые им выведет компилятор будут разными. Следовательно мы не может написать такой код:

{% code lineNumbers="true" %}
```rust
fn make_inc(is_decrement: bool) -> impl Fn(i32) -> i32 {
    if is_decrement {
        move |x| { x - 1 }
    } else {
        move |x| { x + 1 }
    }
}
```
{% endcode %}

Как мы знаем, `impl Трэйт` должно быть заменено на контретный тип во время компиляции, а у этих двух замыканий в строках (3) и (5), конкретные типы разные.

В качестве решения, можно вернуть замыкание с динамической диспетчеризацией, о который мы поговорим в главе [generiki.md](generiki.md "mention").

```rust
fn make_inc(is_decrement: bool) -> Box<dyn Fn(i32) -> i32> {
    if is_decrement {
        Box::new(move |x| { x - 1 })
    } else {
        Box::new(move |x| { x + 1 })
    }
}
fn main() {
    let dec: Box<dyn Fn(i32) -> i32> = make_inc(true);
    let a = 2;
    let b = dec(a);
    println!("{b}"); // 1
}
```
