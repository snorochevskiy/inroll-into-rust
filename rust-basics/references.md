# Ссылки

Ссылка — это переменная, которая "ссылается" на данные, хранимые в другой перменной.

Для создания ссылки на данные, хранимые в переменной, используется оператор `&`.

```rust
let переменная: Тип = значение;
let ссылка: &Тип = &переменная;
```

При этом тип ссылки будет `&тип_изначальной_переменной`.

Например:

```rust
fn main() {
  let a: i32 = 5;
  let ref_a: &i32 = &a;
  println!("Value in a is {}", *ref_a); // Value in a is 5
}
```

Оператор `*` используется для получения значения, на которое ссылается ссылка.

Ссылки, как и переменные, по умолчанию является немутабельным, т.е. с их помощью можно читать значение оригинальной переменной, но не изменять его. Чтобы создать мутабельную ссылку, нужно вместо `&` использовать `&mut`. Разумеется, мутабельную ссылку можно получить только для мутабельной переменной:

```rust
fn main() {
  let mut a: i32 = 5;
  let ref_a: &mut i32 = &mut a;
  *ref_a = 99;
  println!("Value in a is {}", ref_a); // Value in a is 99
}
```

{% hint style="info" %}
В отличии от указателей в C, которые являются физическим типом данных, т.е. ячейкой в памяти, в которой хранится адрес, ссылка в Rust является скорее семантической сущность. В большинстве случаев, создание ссылки в коде, не приводит к созданию дополнительных сущностей в памяти программы: компилятор просто подменяет взаимодействие с ссылкой на взаимодействие с данными непосредственно. Однако на уровне кода программы, ссылка ведёт себя так, словно это физический "указатель" на данные, хранимые в другой переменной.
{% endhint %}

В Rust ссылки являются безопасными: компилятор отслеживает время жизни ссылок относительно времени жизни переменных, на чьи данные они указывает. При попытке сослаться на данные принадлежащие уже уничтоженной переменной, компилятор выдаст ошибку.

Мы поговорим подробнее о ссылка в главе [ownership.md](ownership.md "mention"), а так же в главе [lifetimes.md](lifetimes.md "mention").
