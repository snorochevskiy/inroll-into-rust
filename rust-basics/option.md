# Option

Теперь когда мы разобрались с основной теорией, мы наконец можем переходить к наиболее распространённым типам из стандартной библиотеки. Первым мы рассмотрим наиболее частоиспользуемый тип —  `Option`.&#x20;

## Проблематика

При написании реальных програм, часто возникает ситуация, когда необходимо каким-то образом обозначить отсутствие значения. Например, для хранения полного имени человека (имя, фамилия и отчество) мы можем создать струкутуру вида:

```rust
struct FullName {
    first_name: String,
    last_name: String,
    middle_name: String,
}
```

Однако, есть ситуации, когда отчество может отсутствовать, и это надо как-то отобразить в коде.

Другой вездесущий пример связан с операциями ввода/вывода: читая данные из внешнего источника, мы никогда не можем гаратировать, что получим все ожидаемые значения. Например, мы запрешиваем из базы данных значение записи по её ID, однако такой записи в БД может просто не существовать.

Традиционно, в императивных языках предыдущих поколений, эта проблема решается одним из трёх сопособов:

Способ 1. Резервирование одного из значений, чтобы обозначить отсутствие значения. Например, использовать `-1` для отсутствующего ID, или пустую строку для отсутствующего отчества. Этот подход очень широко распространён в стандартной библиотеке C, и различных системных API. Его недостатком является то, что, во первых, не всегда можно выделить значение, которое будет индикатором отсутствия значения, а во вторых, пользователь API должен знать о таком соглашении.

Способ 2. Введение дополнительного флага — булевого поля, которое указывает что другое поле "пусто". Например:

```rust
struct FullName {
    first_name: String,
    last_name: String,
    middle_name: String,
    is_middle_name_empty: bool,
}
```

Этот подход лишён недостатка связанного с необходиостью выделения "пустого" значения, однако для написания обычной логики программы он крайне неудобен.

Способо 3. Использование нулевого указателя, как индикатора отсутствия значения. Этот подход хоть и удобен, но является причиной самой распостранённой ошибки в программах на C — ошибка сегментации (и на Java — `NullPointerException`). К тому же, такой подход требует размещения значений в куче, что может негативно сказаться на производительности программы.

## Option для "пустых" значений

Для представления отсутствующих значений, в Rust используется тип Option, который объявлен так:

```rust
enum Option<T> {
    Some(T),
    None,
}
```

Как мы видим, это обобщённый перечислимый тип, состоящий из:

* обобщённой кортежной структуры `Some`
* структуры синглтона `None`

Например, мы хотим сделать переменную типа `i32`, которая может быть "пустой".

```rust
let mut maybe_i32: Option<i32>;
maybe_i32 = Some(5); // Записываем в переменную значение
maybe_i32 = None;    // А теперь переменная "пуста"
```

С помощью `Option`, мы можем переписать наш пример структуры для хранения полного имени следующим образом:

```rust
struct FullName {
    first_name: String,
    last_name: String,
    middle_name: Option<String>,
}
```

Другой пример: функция, которая возвращает запись из базы данных по ID записи может иметь вид:

```rust
fn get_record_by_id(id: u64) -> Option<Record> { ... }
```

Как мы видим, `Option` позволяет хранить потенциально пустое значений, при этом:

* не выделять какое-то из возможных значений для индикации отсутствия значения
* не вводить дополнительных неудобных флагов, потому что `Option` — enum, и он уже содержит в себе этот флаг (дискриминатор)
* не бояться получить ошибку обращения по нулевому указателю

## Извлечение значения из Option

Есть несколько способов извлечь значение из `Option`.

Самый прямолинейный — метод `unwrap`:

* Если опшион содержит значение, т.е. является объектом типа `Some(T)` , то метод `unwrap` вернёт значение, хранящееся в нём
* в противном случае программа завершится с паникой.

```rust
fn main() {
    let o: Option<i32> = Some(5);
    let i: i32 = o.unwrap();
}
```

Очевидно, что использовать метод `unwrap` очень небезопасно, поэтому существует метод `unwrap_or`, который позволяет задать значение, которое следует вернуть, исли опшион "пуст".

```rust
fn main() {
    let o: Option<i32> = None;
    let i: i32 = o.unwrap_or(1); // 1
}
```

Другим способом извлечения значения является использование оператора `match`.

```rust
fn main() {
    let o: Option<i32> = Some(5);
    let i: i32 = match o {
        Some(v) => v,
        None    => 1,
    };
}
```

Разумеется, нам не обязательно возвращать занчение из оператора `match`, если того не требует логика нашей программы. Например, мы можем просто напечатать различный вывод:

```rust
fn main() {
    let o: Option<i32> = Some(5);
    match o {
        Some(v) => println!("Number is {v}"),
        None    => println!("Number is empty"),
    };
}
```

Так же, вместе с `Option` очень удобно использоваться оператор `if-let`.

```rust
fn main() {
    let o: Option<i32> = Some(5);
    if let Some(v) {
        println!("Number is {v}");
    } else {
        println!("Number is empty");
    };
}
```

## Комбинаторы Option

API типа `Option` на первый взгляд может показаться слегко громоздки, однако у `Option` есть целый ряд удобных комбинаторов, которые позволяют сделать работу с ним проще и выразительнее.

Первый комбинатор — метод **map** ("отобразить") позволяет преобразовать значение опшиона, если оно существует, или не сделать ничего, если опшион пуст. В качестве аргумента, метод `map` принимает замыкание (или указатель на фунуцию), которое применяет к значению внутри `Option`, если оно — `Some`.

<img src="../.gitbook/assets/file.excalidraw (17).svg" alt="" class="gitbook-drawing">

Пример:

```rust
fn main() {
    let s1: Option<i32> = Some(5);
    let s2: Option<i32> = s1.map(|a| { a + 1 });
    println!("{s2:?}"); // Some(6)
    
    let e1: Option<i32> = None;
    let e2: Option<i32> = e1.map(|a| { a + 1 });
    println!("{e2:?}"); // None
}
```

Более приближенный к жизни пример: есть функция, которая извлекает из базы данных объект пользователя по его ID. Если объект пользователя с заданным ID существуети в БД, то мы берём из объекта пользователя значение поля "имя".

```rust
struct User {
    id: u64,
    name: String,
}

fn get_user_by_id(id: u64) -> Option<User> {
    // Запрос в БД
}

fn get_user_name_by_id(id: u64) -> Option<String> {
    get_user_by_id(id)
        .map(|user| user.name)
}
```

***

Другой комбинатор — метод **flatten** ("сгладить") `Option<Option<T>>` в `Option<T>`.

```rust
fn main() {
    let o1: Option<i32> = Some(1);
    let o2: Option<Option<i32>> = o1.map(|a| Some(a + 1)); // Some(Some(2))
    let o3: Option<i32> = o2.flatten(); // Some(2)
}
```

***

Метод **and\_then** работает как комбинация map и flatten: он сначала применяет к содержимому опшиона функцию, которая возвращает `Option`, а затем "сглаживает" два ошиона в один.

```rust
fn main() {
    let o1: Option<i32> = Some(1);
    let o2: Option<i32> = o1.and_then(|a| Some(a + 1)); // Some(2)
}
```

