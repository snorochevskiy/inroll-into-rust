# Структуры

Одним из представителей составных типов в Rust являются структуры.

**Структура** — именованный набор полей различного типа, который составляет новый тип данных.

Синтаксис объявления структуры следующий:

```rust
struct ИмяСтруктуры {
    поле_1: Тип1,
    поле_2: Тип2,
    ...
    поле_N: ТипN,
}
```

Заметте, что после последнего поля структуры, как и после последнего аргумента при объявлении функции, можно ставить запятую.

Поля структуры, как и переменные, должны именоваться в соответствии со змеинной нотацией. Имена самих структур должны следовать паскалевской нотации (Pascal case): имя начинается с заглавной буквы, и если в названии присутствует несколько слов, то каждое слово так же начинается с заглавной буквы. Например: User, MainAddress, DatabaseConnection.

Пример структуры, которая хранит имя и фамилию человека:

```rust
struct Person {
    first_name: String,
    last_name: String,
}
```

Синтаксис создания экземпляра структуры:

```rust
let переменная = ИмяСтруктуры { поле_1: значение_1,  ..., поле_N: значение_N};
```

Например:

```rust
let person = Person {
    first_name: String::from("John"),
    last_name: String::from("Doe"),
};
```

Доступ к полю структуры осуществляется при помощи точки: `структура.поле`.

```
my_struct.field_1
```

Рассмотрим пример:

```rust
struct Person {
    first_name: String,
    last_name: String,
}

fn get_full_name(p: &Person) -> String {
    format!("{} {}", p.first_name, p.last_name)
}

fn main() {
    let p = Person {
        first_name: "John".to_string(),
        last_name: "Doe".to_string()
    };
    let full_name = get_full_name(&p);
    println!("{}", full_name); // "John Doe"
}
```

Если мы инициализируем поле структуры значением из переменной, чьё имя совпадает с именем этого поля структуры, то вместо `имя_поля: имя_переменной`, можно просто указать переменную.

```rust
let fists_name = String::from("John");
let person = Person {
    first_name,
    last_name: String::from("Doe"),
};
```

Чтобы иметь возможность изменять значения полей у переменной типа структуры, вся переменная должна быть объявлена как мутабельная.

```rust
fn main() {
    let mut p = Person {
        first_name: "John".to_string(),
        last_name: "Doe".to_string()
    };
    p.first_name = "Theodor".to_string();
}
```

## Создание одного экземпляра из другого

Если у нас есть объект структуры, и мы хотим создать из него другой объект этой же структуру, изменив значение некоторых полей, то для такой ситуации есть специальный синтаксис:

```rust
let новый_объект = Структура {
    поле1: новое значение 1,
    поле2: новое значение 2,
    ..старый_объект
};
```

Пример:

```rust
let p1 = Person {
    first_name: "John".to_string(),
    last_name: "Doe".to_string()
};

let p2 = Person { first_name: "Robert".to_string(), ..p1};

println!("{} {}", p2.first_name, p2.last_name); // Robert Doe
```

## Методы

В отличии от традиционных ООП языков, где методы объявляются в теле класса, в Rust методы структуры объявляются отдельно от неё.

Синтаксис:

```rust
impl ИмяСтруктуры {

  // метод, который НЕ меняет вызывающий объект
  fn метод_1(&self, аргумент_1: Тип1, …, аргумент_N: ТипN) -> ТипРезультата {
    ...
  }

  // метод, который меняет вызывающий объект
  fn метод_2(&mut self, аргумент_1: Тип1, …, аргумент_N: ТипN) -> ТипРезультата {
    ...
  }

  // "статический" метод, вызываемый на структуре, а не на объекте структуры
  fn метод_3(аргумент_1: Тип1, …, аргумент_N: ТипN) -> ТипРезультата {
    ...
  }
}
```

Аналогом ключевого слова this из C++ и Java, является ключевое слово `self`, которое надо явно передавать в качесве первого аргумента метода.

* Если метод не меняет состояние объекта, на котором он вызван, то _self_ можно передавать по немутабельной ссылке - `&self` .
* Если же же методу необходимо изменять хотя бы одно из полей структуры, то _self_ необходимо передавать по мутабельной ссылке - `&mut self`.
* В редких случаях, когда метод должен забрать во владение объект, на котором он был вызван, _self_ необходимо передавать по значению - `self`.

Пример:

```rust
struct Person {
  first_name: String,
  last_name: String,
  age: u32
}

impl Person {
  fn new(first: &str, last: &str) -> Person {
    Person {
      first_name: first.to_string(),
      last_name: last.to_string(),
      age: 0
    }
  }
	
  fn change_age(&mut self, new_age: u32) {
    self.age = new_age;
  }
	
  fn introduce(&self) -> String {
    format!("{} {} is {} years old", self.first_name, self.last_name, self.age)
  }
}

fn main() {
  let mut p = Person::new("John", "Doe");
  p.change_age(25);
  println!("{}", p.introduce());
}
```

## Кортежные структуры (tuple structs)

В дополнение к традиционным структурам, которые являются коллекцией именованных полей, Rust предлагает, так называемые, **кортежные структуры**, где поля идентифицируются не именем, а позицией.

Синтаксис:

```rust
struct Имя(Тип1, Тип2, …, ТипN)
```

Пример:

```rust
/// Представляет цвет закодированный RGB каналами
struct RGB (u8, u8, u8);

impl RGB {
    /// Упаковывает все 3 канала в одной 4-байтное число
    fn as_u32(&self) -> u32 {
        ((self.0 as u32) << 16)
            + ((self.1 as u32) << 8)
            + (self.2 as u32)
    }
}

fn main() {
    let mut color: RGB = RGB(255, 0, 0);  // красный цвет
    println!("Red channel: {}", color.0); // Red канал: 255

    color.1 = 255; // Выставляет зелёный канал в 255

    // кортежную структуру можно разложить на составляющие
    // так же как и обычный кортеж
    let RGB(r, g, b) = color;

    println!("R={r}, G={g}, B={b}"); // R=255, G=255, B=0

    println!("As number: {}", color.as_u32());
}
```

Как видим, кортежная структура - это фактически обычный кортеж, только с осмысленным именем, и возможностью добавить к ней дополнительные методы.

## Структуры синглтоны

В Rust есть возможность создать структуру, в которой нет полей. Например:

```rust
struct Universe;
```

Очевидно, что для такой структуры возможен лишь один вариант объекта, поэтому такая структура называется **синглтоном**. Объект структуры синглтон ведёт себя так же, как и объект обычной структуры с полями.

```rust
struct Universe;

impl Universe {
    fn includes(&self, p: &Planet) -> bool {
        true
    }
}

struct Planet {
    name: String
}

fn main() {
    let universe = Universe;

    let earth = Planet { name: "Earth".to_string() };
    println!("{}", universe.includes(&earth)); // true
}
```

Практическое применение таких структур станет понятно после прочтения главы [treity.md](treity.md "mention").

## Лайфтаймы у структур

В главе [lifetimes.md](lifetimes.md "mention") мы узнали, что такое лайфтаймы в целом, и как задавать их для функций. Теперь давайте разберёмся с лайфтаймами для структур.

Если у структуры есть поле, в котором хранится ссылка, то для этой ссылки надо указывать лайфтайм. Это нужно, что того, чтобы компилятор мог сопоставить время жизни поля-ссылки, и время жизни объекта, ссылка на который хранится в поле сруктуры.

Рассмотрим пример. У нас будет строка `String`, которая хранит имя и фамилию, разделённые пробелом. И мы сделаем структуру, с двумя полями: ссылка на часть строки, где хранится имя, и ссылка на часть строки, где хранится фамилия.

{% code lineNumbers="true" %}
```rust
#[derive(Debug)]
struct NameComponents<'a> {
    first_name: &'a str,
    last_name: &'a str,
}

fn main() {
    let full_name = "John Doe".to_string();

    let space_position = full_name.find(" ").unwrap();

    let components = NameComponents {
        first_name: &full_name[0..space_position],
        last_name: &full_name[space_position + 1 ..],
    };
    println!("{components:?}");
    // NameComponents { first_name: "John", last_name: "Doe" }
}
```
{% endcode %}

Благодаря лайфтайму, компилятор проконтроллирует, чтобы объект структуры `NameComponents` не "пережил" объект строки, на который ссылаются его поля. Например, такой вариант не скомпилируется:

```rust
fn main() {
    let components;
    {
        let full_name = "John Doe".to_string();

        let space_position = full_name.find(" ").unwrap();

        // Error: `full_name` does not live long enough
        components = NameComponents {
            first_name: &full_name[0..space_position],
            last_name: &full_name[space_position + 1 ..],
        };
    }
    println!("{components:?}");
}
```

## Лэйаут в памяти

{% hint style="warning" %}
Если вы плохо знакомы с архитектурой компьютера, и плохо понимаете как данные располагаются на стеке, то этот раздел, скорее всего, покажется непонятным. В таком случае не стоит заострять на нём внимание, так как эта информация не пригодится при разработке back-end приложений на Rust. Однако, в будущем настоятельно рекомендуется разобраться с этой темой.
{% endhint %}

Теперь давайте разберёмся как экземпляры структур располагаются в оперативной памяти.

{% hint style="info" %}
Результаты нижеприведённых примеров получены на x86\_64 процессоре и версии Rust 1.89
{% endhint %}

Рассматрим пример:

```rust
struct MyStruct {
    a: i64,
    b: i32, 
}

fn main() {
    println!("Size = {}", std::mem::size_of::<MyStruct>()); // Size = 16
}
```

Как так получается, что структура состоящая из полей чей размер соответственно 8 и 4 байта, занимает 16 байт?

Дело в том, что компилятор применяет так называемое "выравнивание", т.е. располагает поля так, чтобы процессор мог адресовать их за одну операцию считывания/записи.

{% hint style="info" %}
Дело в том, что x86\_64 процессора имеют регистры размером 8 байт. При операциях чтения процессор можно адресовать только блоки памяти чей адрес кратен 8. Например считать в регистр можно блоки ячеек по адресам 0-7, или 8-15, или 16-23 и т.д. Процессор не может запросить ячейки в диапазоне 4-11 или, тем более, 4-7.

Поэтому, когда необходимо вычитать значение, чьё начало расположено по адресу не кратному 8, например, 4-11, то процессору приходится считывать куски из смежных блоков, т.е. 0-7 и 8-16, далее битовыми операциями "отрезать" от них нужную часть, и "склеивать" воедино. Все эти операции занимают лишние машинные такты, поэтому целесообразнее выровнять значения в памяти так, чтобы значения можно было считывать за одну операцию. Пусть платой за это и станет перерасход памяти. Получившиеся "пробелы" в памяти называют паддингами (padding).
{% endhint %}

Давайте посмотрим по каким адресам располагаются поля a и b.

```rust
struct MyStruct {
    a: i32,
    b: i64, 
}

fn main() {
    println!("Size = {}", std::mem::size_of::<MyStruct>()); // Size = 16

    let s = MyStruct { a: 1, b: 2 };
    println!("a: {}", ((&s.a) as *const i32).addr()); // a: 140731421349072
    println!("b: {}", ((&s.b) as *const i64).addr()); // b: 140731421349064
}
```

Оба адреса `140731421349072` и `140731421349064` кратны 8.

{% hint style="info" %}
Обычно для распечатки адреса, используется форматирующая последовательность `{:p}` макроса `println!`, но мы просто хотели наглядно продемонстрировать то, как получается адрес переменной.
{% endhint %}

Теперь давайте посмотрим как располагаются в памяти массивы структур:

```rust
struct MyStruct {
    a: i32,
    b: i64, 
}

fn main() {
    let arr = [
        MyStruct { a: 1, b: 2 },
        MyStruct { a: 3, b: 4 },
        MyStruct { a: 5, b: 6 }
    ];
    println!("arr[0].a: {:p}", &arr[0].a); // arr[0].a: 0x7ffdc124d970
    println!("arr[0].b: {:p}", &arr[0].b); // arr[0].b: 0x7ffdc124d968
    println!("arr[1].a: {:p}", &arr[1].a); // arr[1].a: 0x7ffdc124d980
    println!("arr[1].b: {:p}", &arr[1].b); // arr[1].b: 0x7ffdc124d978
    println!("arr[2].a: {:p}", &arr[2].a); // arr[2].a: 0x7ffdc124d990
    println!("arr[2].b: {:p}", &arr[2].b); // arr[2].b: 0x7ffdc124d988
}
```

В памяти это выглядит так:

<img src="../.gitbook/assets/file.excalidraw (23).svg" alt="" class="gitbook-drawing">

Здесь хорошо видно как выравнивание и паддинги.

Так же, мы видим, что компилятор поменял местами поля `a` и `b`. Да, Rust не гарантирует, что поля структуры в памяти будут иметь тот же порядок, что и в коде объявления структуры.

Если необходимо, чтобы компилятор соблюдал порядок полей в памяти, то структуру следует пометить аннотацией `#[repr(C)]`.

```rust
#[repr(C)]
struct MyStruct {
    a: i32,
    b: i64, 
}
```

Эта аннотация указывает, что структура должна иметь представление совместимое с представлением структур в языке C. А в C порядок полей структуры в памяти должен соответствовать порядку полей в коде структуры.
