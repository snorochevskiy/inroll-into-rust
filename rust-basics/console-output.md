# Печать на консоль

Как мы знаем из примера "Hello World" в главе [first-look.md](first-look.md "mention"), для печати на консоль используется вызов `println!`.

Функция `println!` не так проста как кажется. Да и не функция это никакая, а макрос. Причём, если вы знакомы с макросами в C, то позвольте вас сразу успокоить: в Rust макросы куда безопаснее и удобнее.

Разбираться с тем, как устроены макросы в Rust, и как именно работает макрос `println!` мы будем потом в главе [declarative-macro.md](declarative-macro.md "mention"). А пока что давайте просто посмотрим на примеры использования `println!`, которые нам понадобятся для изучения последующего материала.

***

Мы уже знаем как напечатать на консоль строку: просто передаём строку в `println!`&#x20;

```rust
println!("Print just text");
```

Для того, чтобы вывести на консоль значение переменной, нужно в `println!` передать два аргумента:

* 1-й аргумент: строка, которая содержит текст для вывода на консоль. В том месте, где в строке мы хотим вывести значение переменной, нужно вставить форматирующую комбинацию `{}`&#x20;
* 2-й аргумент: переменная, значение которой встанет на место форматирующей комбинации `{}`

Например:

```rust
fn main() {
    let magic_number: i32 = 5;
    println!("Number is {}", magic_number);
}
```

Если скомпилировать и запустить эту программу, то мы увидим следующее:

<pre><code><strong>$ rustc main.rs
</strong><strong>$ ./main
</strong><strong>Number is 5
</strong></code></pre>

(Это пример сборки и выполнения в Linux. В Windows программа будет называться `main.exe`)

Если мы хотим распечатать две переменные, то, соответственно, указываем две `{}` комбинации, и далее передаём две переменны:

```rust
let number_1 = 5;
let number_2 = 6;
println!("Number 1 is {}, number 2 is {}", number_1, number_2);
```

Так же, переменную можно указывать не вторым параметром, а непосредственно внутри фигурныйх скобок:

```rust
let magic_number: i32 = 5;
println!("Number is {magic_number}");
```

И есть комбинированный вариант: когда внутри `{}` мы задаём псевдоним, а после привязываем к этому псевдониму значение.

```rust
let magic_number: i32 = 5;
println!(
    "Number is {num}, num in the power of two is {square}",
    num = magic_number,
    square = magic_number * magic_number
);
```

***

Вышеуказанным образом, выводить на консоль можно только значения типов, для которых определён трэйт `std::fmt::Display` . Про трейты мы поговорим позже, а пока что нам нужно знать то, что через `{}` можно передавать только значения типов, для которых явно прописано как значениея этих типов преобразуются в строки.

Для всех примитивных типов в стандартной бибилиотеке Rust уже имеется реализация `std::fmt::Display` , что позволяет непосредственно выводить их через `println!`. Но для большей части типов (например, для массивов) это не так.

Однако, если в `println!` строке заменить `{}` на `{:?}` , то мы сможем выводить значения типов, для которых определён трэйт `std::fmt::Debug`, а таких типов подавляющее большинство.

Пока что не заостряйте своё внимание на этом моменте, так как мы его коснёмся еще не раз.
