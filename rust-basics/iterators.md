# Итераторы

Как мы знаем, цикл `for` можно использовать для перебора элементов разных типов: массив, слайс, вектор, диапазон, и т.д. Но за счёт чего достигается такая гибкость?

Дело в том, что цикл `for` умеет перебирать только итераторы, которые в свою очередь являются единый интерфейсом для работы с последовательностями. Если мы хотим, чтобы наш тип коллекции можно было перебирать циклом `for`, мы должны предоставить механизм получения итератора для него.

Для начала, давайте разберёмся с самими итераторами.

Трэйт [**Iterator**](https://doc.rust-lang.org/std/iter/trait.Iterator.html) объявляет интерфейс для итератор — типа, который позволяет последовательно перебирать объекты в некой коллекции (массив, слайс, вектор), с которой итератор связан.

```rust
pub trait Iterator {
    type Item;
    
    fn next(&mut self) -> Option<Self::Item>;
    
    // ... более 70 других методов
}
```

Самый главный метод этого трэйта — `next`, который возвращает:

* либо следующий элемент в перебираемой последвательность в форме `Some(значение)`,&#x20;
* либо `None`, если все элементы перебраны.

Именно метод `next` используется циклом `for` для получения следующего элемента.

## Делаем итератор

Чтобы было проще разобраться, давайте создадим свой итератор для вектора. Стандартная библиотека уже содержит стандартную реализацию итератора для вектора — тип [**Iter**](https://doc.rust-lang.org/beta/core/slice/struct.Iter.html). Поэтому, чтобы не смущать компилятор попытками понять какую же реализацию итератора он должен использовать (стандартную или нашу), мы сделаем обёртку над вектором.

```rust
struct MyVec<T>(Vec<T>);
```

Теперь сделаем итератор для нашей обёртки:

```rust
struct MyVecIter<'a, T> {
    data: &'a MyVec<T>,
    current_ind: usize,
}

impl <'a, T> Iterator for MyVecIter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        if self.current_ind < self.data.0.len() {
            let current_element = &self.data.0[self.current_ind];
            self.current_ind += 1;
            Some(current_element)
        } else {
            None
        }
    }
}
```

Наш итератор — просто структура, которая хранит ссылку на объект `MyVec` и индекс того элемента, который будет извлечен при вызове `next()`.

Если индекс еще не вышел за границы итерируемого вектора, то мы возвращаем ссылку на элемент, находящийся по этому индексу, и инкрементируем индекс. Если индекс вышел за границы вектора, то возвращаем `None`, который служит сигналом того, что итерация звершена.

Пример использования нашего итератора:

```rust
fn main() {
    let my_vec = MyVec(vec![1,2,3]);
    let iterator = MyVecIter { data: &my_vec, index: 0 }; 
    for n in iterator {
        print!("{n} ");
    }
    // Напечатает: 1 2 3
}
```

Разумеется, создавать итератор вот так вручную — очень неудобно. Поэтому, в коллекцию, по которой можно итерироваться, часто добавляют метод `iter()`, который сам конструирует итератор.

```rust
impl <T> MyVec<T> {
    fn iter(&self) -> MyVecIter<'_, T> {
        MyVecIter { data: self, index: 0 }
    }
}
```

Теперь итерироваться циклом `for` гораздо удобнее:

```rust
fn main() {
    let my_vec = MyVec(vec![1,2,3]);
    for n in my_vec.iter() {
        print!("{n}, ");
    }
}
```

Название `iter()` не регламентировано никаким трейтом, и является просто понятным общепринятым именем.

## Цикл for и итераторы

Теперь когда мы выяснили, что цикл `for` на самом деле работает только с итераторами, давайте выясним как же цикл `for` итерируется непосредственно по вектору.

Всё просто: цикл `for` принимает либо непосредственно итератор, либо тип, который реализует трэйт [**IntoIterator**](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html).

```rust
pub trait IntoIterator {
    // Тип элемента итератора
    type Item;

    // Тип итератора
    type IntoIter: Iterator<Item = Self::Item>;

    // Возвращает объект итератора
    fn into_iter(self) -> Self::IntoIter;
}
```

То есть, если мы ходим передавать объект `MyVec` в цикл `for` непосредственно, то мы должны реализовать для него трэйт `IntoIterator`.

```rust
impl <'a, T> IntoIterator for &'a MyVec<T> {
    type Item = &'a T;

    type IntoIter = MyVecIter<'a, T>;

    fn into_iter(self) -> Self::IntoIter {
        MyVecIter { data: self, index: 0 }
    }
}
```

Поскольку мы итерируемся по элементам через ссылку, а не по значению, то `IntoIterator` мы реализуем не для `MyVec`, а для ссылки `&MyVec`.

Теперь, когда `IntoIterator` определён, мы можем итерироваться по объекту `MyVec` так:

```rust
fn main() {
    let my_vec = MyVec(vec![1,2,3]);

    for n in &my_vec {
        print!("{n}, ");
    }
}
```

Вся программа целиком:

<details>

<summary>Пример итератора</summary>

```rust
struct MyVec<T>(Vec<T>);

struct MyVecIter<'a, T> {
    data: &'a MyVec<T>,
    index: usize,
}

impl <T> MyVec<T> {
    fn iter(&self) -> MyVecIter<'_, T> {
        MyVecIter { data: self, index: 0 }
    }
}

impl <'a, T> Iterator for MyVecIter<'a, T> {
    type Item = &'a T;
    fn next(&mut self) -> Option<Self::Item> {
        if self.index < self.data.0.len() {
            let current_element = &self.data.0[self.index];
            self.index += 1;
            Some(current_element)
        } else {
            None
        }
    }
}

impl <'a, T> IntoIterator for &'a MyVec<T> {
    type Item = &'a T;

    type IntoIter = MyVecIter<'a, T>;

    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}

fn main() {
    let my_vec = MyVec(vec![1,2,3]);

    for n in &my_vec {
        print!("{n}, ");
    }
}

```

</details>

А можно ли итерироваться по элементам нашей обёртки не по ссылке, а по значению? Да, однако, нам придётся написать второй итератор, который будет захватывать нашу обёртку по значению:

```rust
struct MyVec<T>(Vec<T>);

struct MyVecIterVal<T> {
    data: MyVec<T>,
}

impl <T> MyVec<T> {
    fn iter_val(self) -> MyVecIterVal<T> {
        MyVecIterVal { data: self }
    }
}

impl <T> Iterator for MyVecIterVal<T> {
    type Item = T;
    fn next(&mut self) -> Option<Self::Item> {
        self.data.0.pop() // извлекаем и возвращаем первый элемент
    }
}

impl <T> IntoIterator for MyVec<T> {
    type Item = T;

    type IntoIter = MyVecIterVal<T>;

    fn into_iter(self) -> Self::IntoIter {
        self.iter_val()
    }
}

fn main() {
    let my_vec = MyVec(vec![1,2,3]);

    for n in my_vec {
        print!("{n}, ");
    }
}
```

## Еще раз про итерирование по вектору

Теперь, когда мы познакомились с трэйтами `Iterator` и `IntoIterator`, давайте посмотрим на несколько примеров итерирования по уже знакомым типам.

```rust
let v = vec![1, 2, 3];

// Метод iter() определен для типа Vec.
// Он явно возвращает объект итератора, который перебирает ссылки на элементы
// Тип i: &i32
for i in v.iter() { }

// На объекте &Vec будет неявно вызван метод into_iter(),
// который вернёт итератор. Тип i: &i32
for i in &v { }

// Явный вызов into_iter() для объекта Vec. Вернёт итератор для перебора
// элементов по значению, т.е. итерирование "поглотит вектор". Тип i: i32
for i in v.into_iter() { }

// Неявно вызовет into_iter() для объекта Vec.
for i in v { }
```

Точно такая же картина для массивов:

```rust
let arr = [1, 2, 3];

// Перебор по ссылке - i: &i32
for i in arr.iter() { }

// Перебор по ссылке - i: &i32
for i in &arr { }

// Перебор по значению - i: i32
for i in arr.into_iter() { }

// Перебор по значению - i: i32
for i in arr { }
```

Резюмируя:

* если мы хотим проитерироваться по коллекции, перебирая значения по ссылке, тогда следует передавать в оператор `for` либо ссылку на коллекцию, либо вызывать на объекте коллекции метод `iter()` (если таков имеется).
* если нам нужны именно значения элементов (и нам подходит разрушение самой коллекции), то следует передавать в оператор `for` либо объект коллекции непосредственно, либо вызвать метод `into_iter()`

## Range

В главе [loops.md](loops.md "mention") мы видели такую форму перебора чисел

```rust
for i in 0 .. 20 {
    println!("{i}");
}
```

Дело в том, что оператор `..` создаёт объект типа [**Range**](https://doc.rust-lang.org/std/ops/struct.Range.html) — диапазон, который хранит начальное и конечно значения диапазона. При этом типа `Range` реализует интерфейс `Iterator`, что позволяет итерироваться по его элементам.

При желании мы можем использоваться `Range` и без цикла `for`.

```rust
use std::ops::Range;

fn main() {
    let mut range: Range<i32> = 0..20;
    println!("{:?}", range.next()); // Some(0)
    println!("{:?}", range.next()); // Some(1)
}
```

## API итераторов

Как мы заметили в самом начале, в трэйте `Iterator` кроме метода  `next()`, определено еще более 70 методов, которые имеют реализацию по-умолчанию. Что же это за методы?

Это методы позволяющие декларативно обрабатывать и преобразовывать коллекции.

{% hint style="info" %}
Программисты на Java могут провести аналогию с Stream API, а программисты на C# с Linq.
{% endhint %}

Начнём с примера: у нас есть вектор чисел, и мы хотим взять из него только чётные числа, каждый из которых далее мы хотим возвести в квадрат.

```rust
let v1 = vec![1,2,3,4,5];
let v2 = v1.into_iter()
    .filter(|x| x % 2 == 0)
    .map(|x| x * x)
    .collect::<Vec<_>>();
println!("{v2:?}"); // [4, 16]
```

Здесь мы:

1. Получаем итератор для вектора. После завершения обработки нам больше не нужен оригинальный вектор, поэтому мы вызываем `into_iter()`, который "поглотит" вектор при итерировании
2.  На полученном итераторе, мы вызываем метод `filter`, который имеет вид:

    ```rust
    fn filter<P>(self, predicate: P) -> Filter<Self, P>
        where Self: Sized, P: FnMut(&Self::Item) -> bool
    {
        Filter::new(self, predicate)
    }
    ```

    Как мы видим, этот метод принимает некий предикат, и возвращает объект `Filter`.

    ```rust
    pub struct Filter<I, P> {
        pub(crate) iter: I,
        predicate: P,
    }
    ```

    Тип `Filter` — это обёртка над итератором, которая хранит в себе итератор и предикат, которым его надо профильтровать. И разумеется, тип `Filter`, тоже реализует трэйт `Iterator`.
3.  Уже на объекте `Filter` мы вызывает другой метод, определённый в трэйте `Iterator` - метод `map`:

    ```rust
    fn map<B, F>(self, f: F) -> Map<Self, F>
    where Self: Sized, F: FnMut(Self::Item) -> B,
    {
        Map::new(self, f)
    }
    ```

    Как видим, этот метод очень напоминает `filter`, за исключением того, что он возвращает объект типа `Map`, который объявлен так:

    ```rust
    pub struct Map<I, F> {
        pub(crate) iter: I,
        f: F,
    }
    ```

    То есть `Map` — это обёртка над итератором, которая хранит функцию, при помощи которой нужно преобразовать элементы обёрнутого итератора.
4. На объекте `Map` мы вызываем метод `collect()`, определеённый в трэйте `Iterator`, и только в этот момент начинается раскрутка обёрток и вычисление результата.\
   Каким будет тип результата, зависит от генерик тип-аргумента метода `collect()`.

Эта "матрёшка" из вектор-итератора, завёрнутого в `Filter`, и завёрнутого в `Map` выглядит примерно так:

<img src="../.gitbook/assets/file.excalidraw (13).svg" alt="" class="gitbook-drawing">

В примере выше, мы обработали вектор, и получали результат тоже в форме вектора (так как в метод `collect` передали тип-агрумент `Vec`). Если бы мы хотели получить результирующий элементы в виде, например, [**HashSet**](https://doc.rust-lang.org/std/collections/struct.HashSet.html) (хэш-множество), то просто должны были бы указать этот вид коллекций в методе `collect()`.

```rust
use std::collections::HashSet;

fn main() {
    let v1: Vec<i32> = vec![1,2,3,4,5];
    let v2: HashSet<i32> = v1.into_iter()
        .filter(|x| x % 2 == 0)
        .map(|x| x * x)
        .collect::<HashSet<_>>();
    println!("{v2:?}"); // {16, 4}
}
```

Для большинства коллекций, из стандартной библиотеки, можно получить итератор, и большинство коллекций, из стандартной библиотеки, могут быть построены из итератора методом `collect`. Получается, что итератор — универсальное API для обработки и преобразования типов-коллекций.

<img src="../.gitbook/assets/file.excalidraw (14).svg" alt="" class="gitbook-drawing">

Большинство коллекций из сторонних библиотек, так же работают вместе с итераторами.

## Свёртки

Итератор не обязательно использовать для создания другой коллекции, он так же позволяет "сворачивать" (агрегировать) элементы. Для этого трэйт `Iterator` предоставляет функцию `fold`:

```rust
fn fold<B, F>(mut self, init: B, mut f: F) -> B
    where F: FnMut(B, Self::Item) -> B
{ ... }
```

Этот метод принимает два аргумент:

1. начальное значение, с которым мы будем "сворачивать" (агрегировать)
2. агрегирующую функцию, которая принимает уже сагрегированное значение и следующий элемент из итератора, и возвращает результат агрегации

Например, суммируем элементы массива про помощи свёртки.

```rust
let arr = [1, 2, 3];
let sum = arr.into_iter()
    .fold(0, |x, y| x + y);
println!("{sum}"); // 6
```

Здесь свёртка происходит примерно так:

<img src="../.gitbook/assets/file.excalidraw (15).svg" alt="" class="gitbook-drawing">

Возможно, у вас появился вопрос: а для чего нам начальное значение `0`, если в качестве начального значения агрегации мы просто могли использовать первый элемент?

Во первых, на самом деле в трэйте `Iterator` есть метод `reduce`, который работает практически так же как и `fold`, только в качестве начального значения берётся первый элемент.

```rust
let arr = [1, 2, 3];
let sum: Option<i32> = arr.into_iter()
    .reduce(|x, y| x + y);
println!("{sum:?}"); // Some(6)
```

(`reduce` возвращает `Option`, так как в сворачиваемой коллекции может вообще не быть элементов)

А во вторых, при использовании `fold`, результат агрегации может иметь тип, отличный от типа итерируемых элементов. Например, при помощи `fold` мы можем проитерироваться по массиву строк, и подсчитать количество символов во всех строках:

```rust
let arr = ["aa", "bbb", "cccc"];
let char_count = arr.iter()
    .fold(0, |count, s| count + s.len());
println!("{char_count}"); // 9
```

***

Так же следует заметить, что для итератора определён ряд [специализаций](generics.md#specializaciya-treita).

Например, для итератора с элементами числового типа, есть дополнительный метод `sum`, который считает сумму всех элементов:

```rust
fn main() {
    let arr = [1, 2, 3];
    let sum: i32 = arr.into_iter().sum();
    println!("{sum}");
}
```

## Другие методы

### filter\_map

Метод `filter_map` работает как обычный `map`, однако функция-преобразователь, которую он принимает в качестве аргумента, должна возвращать значение, завёрнутое в `Option`.

Если функция-преобразователь, после применения к очередному элементу, вернёт `Some(значение)`, то значение будет автоматически извлечено и пойдёт "дальше по конвееру итератора". А если функция вернёт `None`, то это `None` будет просто отброшено.

Пример: получение квадратных корней всех элементов, из которых можно извлечь корень.

```rust
fn safe_sqrt(n: f32) -> Option<f32> {
    if n < 0.0 {
        None
    } else {
        Some(n.sqrt())
    }
}

fn main() {
    let arr = [4.0, -25.0, 9.0];
    let result = arr.into_iter()
        .filter_map(safe_sqrt)
        .collect::<Vec<_>>();
    println!("{result:?}"); // [2.0, 3.0]
}
```

### find

Метод `filter` принимает предикат, и возвращает первый элемент, который удовлетворяет этому предикату.

```rust
let arr = [1, 3, 5, 7, 8, 9];
let first_even: Option<i32> = arr.into_iter()
    .find(|x| x % 2 == 0);
println!("{first_even:?}");
```

Метод возвращает значение завёрнутое в `Option`, так как есть вероятность, что ниодин элемент не удовлетворит предикату.

{% hint style="info" %}
В трэйте `Iterator` определено много полезны методов, тем не менее, на практике, вам скорее всего вам пригодится библиотека itertools, которая предлагает целое множество дополнительных методов.
{% endhint %}
