# Трэйты

{% hint style="info" %}
В русскоязычной литературе по Rust, слово trait переводят по-разному: примесь, типаж. Мы будем использовать англицизм "трэйт", потому что так говорят даже в русскоязычной среде при обсуждении языка Rust.
{% endhint %}

Трэйты подобны интерфейсам из Java: они декларируют наборы методов, которые должны быть определены для типа, который реализует трэйт.

Синтаксис объявления трэйта:

```rust
trait Имя {
    fn метод_1(&self) -> Тип1;
    ...
    fn метод_N(&self) -> ТипN;
}
```

Синтаксис реализации трэйта для структуры:

```rust
impl Трэйт for Структура {
    fn метод_1(&self) -> Тип1 { ... }
    ...
    fn метод_N(&self) -> ТипN { ... }
}
```

Пример:

{% code lineNumbers="true" %}
```rust
// трэйт, который говорит о том, что тип реализующий его,
// умеет представиться
trait CanIntroduce {
    // метод "представиться"
    fn introduce(&self) -> String;
}

struct Person {
    name: String
}

impl CanIntroduce for Person {
    fn introduce(&self) -> String {
        // Человек представляется называя своё имя
        format!("Hello, I'm {}", self.name)
    }
}

fn main() {
    let person = Person { name: String::from("John") };

    println!("{}", person.introduce ()); // Hello, I'm John
}
```
{% endcode %}

## Полиморфизм

Разумеется трэйты не нужны просто для того, чтобы их реализовывать. Главное применение трэйтов — иметь возможность писать полиморфный код, то есть такой, который взаимодействует с типами не напрямую, а через трэйт, который они реализуют.

В Rust есть два принципиально разных способа передать в функцию аргумент по его трейту, а не конкретному типу:

* Статическая диспетчеризация: указать тип аргумента как `impl Трэйт`
* Динамическая диспетчеризация: указать тип аргумента как `dyn Трэйт`

Если вы программируете на C++, то скорее всего вы уже поняли, что это означает. В противном случае, давайте рассмотрим каждый из этих двух типов.

### Статическая диспетчеризация

Для того, чтобы функция принимала аргументы по трэйту со статической диспетчеризацией, надо объявить аргумент с типом `impl Трэйт`.

Напишем функцию, которая принимает любой тип, реализующий трэйт `CanIntroduce` из примера выше, и печатает "представление" на консоль :

```rust
fn print_introduction(v: &impl CanIntroduce) {
    println!("Value says: {}", v.introduce());
}
```

Разумеется, так как мы принимает аргумент по его трэйту, единственное, что мы можем с ним делать, это то, что объявлено в трэйте. Но это как раз то, что нам нужно.

Для того, чтобы продемонстрировать как эта функция может принимать аргументы разных типов, в дополнению к структуре `Person`, давайте создадим еще структуру `Dog`, которая так же реализует трэйт `CanIntroduce`.&#x20;

```rust
struct Dog {
    name: String
}

impl CanIntroduce for Dog {
    fn introduce(&self) -> String {
        // Вне зависимости от своего имени, собака может только погавкать
        String::from("Waf-waf")
    }
}
```

Теперь давайте посмотрим, как можно вызвать функцию `print_introduction` и для `Person`, и для `Dog`.

<pre class="language-rust"><code class="lang-rust"><strong>fn main() {
</strong>    let person = Person { name: String::from("John") };
    let dog    = Dog    { name: String::from("Bark") };

    print_introduction(&#x26;person); // Value says: Hello, I'm John
    print_introduction(&#x26;dog);    // Value says: Waf-waf
}
</code></pre>

А теперь давайте поговорим о том, как это работает, и почему диспетчеризация называется статической.

Дело в том, что когда компилятор встречает использование функции, имеющий `impl Трэйт` аргумент, он генерирует вариант этой функции для контретного типа, с которым функция вызвана. Генерация функции с конкретным типом вместо трэйта, называется **мономорфизацией**.

То есть, найдя вызов функции `print_introduction` для `Person`, а потом для `Dog`, компилятор сгенерирует, что-то вроде (разумеется, имена будут не такими):

```rust
fn print_introduction_$Person(v: &Person) {
    println!("Value says: {}", v.introduce());
}
fn print_introduction_$Dog(v: &Dog) {
    println!("Value says: {}", v.introduce());
}
```

А далее, компилятор изменит вызовы абстрактной `print_introduction`, на вызовы конкретных вариантов:

<pre class="language-rust"><code class="lang-rust"><strong>fn main() {
</strong>    let person = Person { name: String::from("John") };
    let dog    = Dog    { name: String::from("Bark") };

    print_introduction_$Person(&#x26;person);
    print_introduction_$Dog(&#x26;dog);
}
</code></pre>

Таким образом, уже при компиляции, каждый из сгенерированных вариантов функции `print_introduction` будет знать с каким именно конкретным типом он работает, а значит ему будет известен адрес нужного метода `introduce` именно для того типа, с которым работает этот вариант `print_introduction`.

<img src="../.gitbook/assets/file.excalidraw (2) (1) (1).svg" alt="" class="gitbook-drawing">

Все адреса методов статичны, поэтому диспетчеризация и называется статической.\


### Динамическая диспетчеризация

В противовес статической диспетчеризации, существует и динамическая. На первый взгляд, различие в коде между статической диспетчеризацией и динамической - минимально: нужно просто `impl Трэйт` заменить на `dyn Трэйт`.

Вот как будет выглядеть вариант `print_introduction` с динамической диспетчеризацией:

```rust
fn print_introduction(v: &dyn CanIntroduce) {
    println!("Value says: {}", v.introduce());
}
```

При этом вызовы этой функции для типов Person и Dog вообще не изменились:

```rust
fn main() {
    let person = Person { name: String::from("John") };
    let dog    = Dog    { name: String::from("Bark") };

    print_introduction(&person); // Value says: Hello, I'm John
    print_introduction(&dog);    // Value says: Waf-waf
}
```

На первый взгляд, разницы нет, но внутри всё работает совершенно по-другому. Если при статической диспетчеризации, компилятор генерирует столько вариантов функции, сколько различных типов для которых она вызывается, то при динамической диспетчеризации, функция всего одна.

Каким же тогда образом `print_introduction` понимает для какой реализацией `CanIntroduce` она вызвана, и какой из вариантов метода `introduce` следует вызвать? Дело в том, что аргумент `&dyn CanIntroduce` - это не просто ссылка на объект, переданный в качестве аргумента, это две сслыки: первая — на сам объекта, а вторая — на **vtable** (таблица виртуальных вызовов) для конкретного типа аргумента.

Когда компилятор замечает, что объект некого типа передаётся как аргумент с динамической диспетчеризацией, то он генерирует специальную таблица, в которой хранятся имена методов для  этого типа, и адреса этих методов (именно для этого типа) в сегмента кода.

В самой же функции, которая принимает аргумент с динамической диспетчеризацией, вставляется код, который ищёт в таблица виртуальных методов адрес с нужной функцией, а потом вызывает её.

Чтобы всё это работало, при передаче объекта в функцию в качестве `dyn Трэйт` аргумента, компилятор генерирует код, который передаёт в функцию не только адрес объекта, но и адрес соответствующей vtable.

<img src="../.gitbook/assets/file.excalidraw (3) (1) (1).svg" alt="" class="gitbook-drawing">

Этот `dyn Трэйт`, который состоит из пары (ссылка на значение, ссылка на vtable), называется **трэйт объектом** (**trait object**).

### impl vs dyn

Подведём итог. Есть два способа обращения к типу через реализуемый им трэйт:

* `impl Трэйт` — заменяется на конкретный тип при компиляции
* `dyn Трэйт` — заменяется на трэйт объект, который проксиреут вызовы методов на реальный тип при помощи динамической диспетчеризации

{% hint style="info" %}
Если вы не знакомы с C++, детали динамической диспетчеризации, скорее всего, будут плохо понятны. Не пытайтесь понять всё досконально за раз, просто вернитесь к этой теме потом, после того как освоитесь с Rust на базовом уровне, и будете готовы к более глубокому изучению.
{% endhint %}

На данном этапе мы еще не имеем достаточно знаний, чтобы рассмотреть все аспекты использования трэйт объектов, но пока что можем сказать следующее:

* Вызовы методов по средствам статической типизации работают гораздо быстрее, потому что вызов осуществляется напрямую по адресу метода, в то время как при динамической диспетчерезации сначала нужно найти адрес метода в vtable.
* Так как при статической диспетчеризации `impl Трэйт` просто подменяется на конкретный тип, то такой агрумент можно передавать как по ссылке `&impl Трэйт`, так и по значению — просто `impl Трэйт`.
* В отличии от `impl Трэйт`, `dyn Трэйт` нельзя передать по значению, так как для вызова функции необходимо знать точный размер аргумента. Но конкретный тип аргумента не известен, а следовательно, не известен и его размер. По этой причине, трэйт объект всегда передается либо по ссылке — `&dyn Трэйт`, или через указатель.

## Реализация трэйта для "чужих" типов

Поскольку имплементация трэйт для структуры происходит за пределами тела самой структуры (в отличии от интерфейсов и абстрактных классов в ООП языках), становится возможным имплементировать трэйт для структуры, которая нам "не принадлежат" (находится в другой библиотеке).

```rust
trait CanIntroduce {
    fn introduce(&self) -> String;
}

impl CanIntroduce for &str {
    fn introduce(&self) -> String {
        String::from("I am string slice")
    }
}

impl CanIntroduce for i32 {
    fn introduce(&self) -> String {
        String::from("I am integer")
    }
}

fn print_introduction(v: impl CanIntroduce) {
    println!("Value says: {}", v.introduce());
}

fn main() {
    print_introduction("a"); // Value says: I am string slice
    print_introduction(5);   // Value says: I am integer
}
```

В Rust существует правило "Orphan rule" (правило сирот), которое гласит: трэйт можно реализовать для типа, только в том случае, если либо трэйт, либо тип (либо оба) принадлежит библиотеке в которой осуществляется реализация.

То есть, не смотря на то, что тип `i32` принадлежит стандартной библиотеке, мы смогли реализовать для него трэйт `CanIntroduce` только потому что, трэйт `CanIntroduce` объявлен нами в нашей программе. Мы не можем определить трэйт из "чужой" библиотеки для типа из "чужой" библиотеки. Либо трэйт, либо тип должен принадлежать нашему `main.rs` или его модулям.

В главе [#newtype-pattern](treity.md#newtype-pattern "mention") мы подробнее рассмотрим Orphan rule, и способ обхода этого ограничения.

## Возврат трэйта из функции

Rust можно не только передавать аргументы по средствам трэйта, но и возвращать трэйт из функции.

Принцип такой же, как и с передачей аргументов:

* если возвращаемый тип `impl Trait`, то компилятор проведёт замену на конкретный тип
* если возвращаемый тип `dyn Trait`, то компилятор создаст трэйт объект

Например:

```rust
fn make_person() -> impl CanIntroduce {
    Person { name: String::from("John") }
}
```

Однако есть нюанс: поскольку компилятор просто заменяет `impl Трэйт` на конкретный тип, из такой функции нельзя возвращаться два разных типа.

Рассмотрим пример:

```rust
fn make_someone(is_person: bool) -> impl CanIntroduce {
    if is_person {
        Person { name: String::from("John") }
    } else {
        Dog { name: String::from("Bark") }
    }
}
```

Такая функция невозможна, так как `impl CanIntroduce` должен быть заменён на конкртеный тип, но если он будет заменён на `Person`, то возврат объекта `Dog` будет не корректен, и наоборот.&#x20;

Возврат `dyn Трэйт` в этой ситуации работает прекрасно:

```rust
fn make_someone(is_person: bool) -> Box<dyn CanIntroduce> {
    if is_person {
        Box::new(Person { name: String::from("John") })
    } else {
        Box::new(Dog { name: String::from("Bark") })
    }
}

fn main() {
    let person = make_someone(true);
    let dog    = make_someone(false);

    print_introduction(person.as_ref());
    print_introduction(dog.as_ref());
}
```

В этом примере присутствует тип, с которым мы пока еще не знакомы — `Box`. Это фактически просто безопасная обёртка над указателем. Конструктор `Box::new(значение)`, переносит значение со стека в кучу, и возвращает объект `Box`, внутри которого содержится указатель с адресом объекта в куче. Подробнее мы разберём Box в главе [smart-pointers.md](smart-pointers.md "mention").

Главная причина по которой мы используем `Box<dyn Трэйт>`, а не `&dyn Трэйт` заключается в том, что мы не можем вернуть ссылку на объект, который создан на стеке при выполнении функции. Ведь при выходе из функции, её стэк-фрэйм будет очищен вместе со всеми находящимися в нём объектами, и ссылка на любой из этих объектов станет недействительной. Именно поэтому мы переносим объект в кучу, и возвращаем из функции указатель (Box) на этот объект в куче.

## Дефолтные имплементации методов

Методы в трэйте могут иметь реализации по умолчанию. Разумеется, их тоже можно переопределить при необходимости.

```rust
trait CanIntroduce {
    fn say_name(&self) -> String;
    fn introduce(&self) -> String { // реализация по умолчанию
        format!("Hello, I am {}", self.say_name())
    }
}

struct Person {
    name: String
}

impl CanIntroduce for Person {
    fn say_name(&self) -> String {
        self.name.clone()
    }
}

fn main() {
    let person = Person { name: String::from("John") };
    // Вызываем дефолтную реализацию метода introduce
    println!("{}", person.introduce()); // Hello, I am John
}
```

Методы с реализацией по умолчанию переопределяются так же, как и обычные методы трэйтов:

```rust
impl CanIntroduce for Person {
    fn say_name(&self) -> String {
        self.name.clone()
    }
    fn introduce(&self) -> String { // переопределяем
        format!("Hi, I'am {}", self.say_name())
    }
}
```

## "Наследование" трэйта

В Rust трэйт может "наследовать" другой трэйт.

```rust
trait A : B { ... } // Трэйт A "наследует" трэйт B
```

На практике это означает, что если мы хотим реализовать для нашего типа трэйт A, то мы обязательно должны реализовать и трэйт B для него.

Например:

```rust
trait HasName {
    fn say_name(&self) -> String;
}

// Все кто реализуют CanIntroduce, должны реализовать и HasName
trait CanIntroduce : HasName {
    fn introduce(&self) -> String;
}

struct Person {
    name: String
}

impl CanIntroduce for Person {
    fn introduce(&self) -> String {
        format!("Hello, I am {}", self.say_name())
    }
}

// Компилятор обяжет сделать реализацию для HasName
// после того как найдёт реализацию для CanIntroduce
impl HasName for Person {
    fn say_name(&self) -> String {
        self.name.clone()
    }
}

fn main() {
    let person = Person { name: String::from("John") };
    println!("{}", person.introduce()); // Hello, I am John
}
```

## Ограничение несколькими трэйтами

Когда мы указываем трэйт в качестве аргумента функции, мы по сути, накладываем ограничение на типы, которые можно передавать в эту функцию.

Например, объявляя аргумент так:

```rust
fn print_introduction(v: impl CanIntroduce) { ... }
```

мы накладываем ограничение, что функция может быть вызвана только с аргументом, чей тип реализует трэйт `CanIntroduce`. Но что, если нам нужно, чтобы агрумент реализовывал два трэйта? В таком случае, надо просто перечислить необходимые трэйты через знак `+`.

```rust
trait CanIntroduce { ... }
trait HasJob { ... }

fn print_worker_introduction(v: &(impl CanIntroduce + HasJob)) {
```

Важно сказать, что такой синтаксис для указания ограничения в виде нескольких трэйтов практически никогда не используется. Вместо него используется другой синтаксис, который мы рассмотрим в главе [generics.md](generics.md "mention").

### Self

Не редко, в объявлении трэйта необходимо сослаться на конкретный тип, для которого будет реализован трэйт. Для этого используется ключевое слово `Self` (с заглавной буквы).

Например, создадим трэйт, который декларирует, что у типа должена быть функция-конструктор по умолчанию:

```rust
trait HasDefaultConstructor {
    fn make_default() -> Self;
}
```

Когда мы пишем этот трэйт, мы еще не знаем, какой тип будет возвращать функция `make_default`, так как он будет зависеть от типа, для которого мы реализует этот трэйт. Поэтому мы не можем указать конкретное имя типа в типе результата функции. Именно здесь на помощь приходит `Self`.

Давайте теперь реализуем этот трэйт для типа `Person` из примеров выше:

```rust
struct Person {
    name: String
}

impl HasDefaultConstructor for Person {
    fn make_default() -> Self {
        Person { name: "Anonymous".to_string() }
    }
}

fn main() {
    let p = Person::make_default();
    println!("Default name: {}", p.name);
}
```

В реализации методов трэйта можно оставить `Self`: `fn make_default() -> Self`.\
Но можно и заменить на имя конкретного типа `fn make_default() -> Person` — эффект будет одинаковым.

## Требования к Трэйт-объектам

На последок мы должны сказать, что не для всех трэйтов можно создать трэйт объект. Трэйт должен удовлетворять следующим требованиям:

*   Трэйт не должен содержать методов, которые декларируют новый генерик-тип аргумент, не связанный с генерик-тип аргументом заданным на уровне самого трэйта. О [генериках](generics.md) мы поговорим в другой главе. Например, для такого трэйта нельзя создать трэйт-объект.

    ```rust
    trait A {
        fn f<T>();
    }
    ```
*   Трэйт не должен содержать ассоциированных типов:

    ```rust
    trait A {
        type X;
    }
    ```
*   Трэйт не должен содержать методов, которые возвращают `Self` или принимают аргумент типа `Self`.

    ```rust
    trait A {
        fn f(&self, other: &Self) -> Self;
    }
    ```

Если трэйт наследует другие трэйты, то все наследуемые трэйта так же должны удовлетворять вышеприведённым условиями для преобразования в трэйт-объект.

## unsafe trait

Если мы создаём трэйт, содержащий методы, которые предполагают _unsafe_ операции, такие как работа с указателями, то трэйт следует объявить с ключевым словом `unsafe`.

```rust
unsafe trait MyTrair {
    fn do_something_dangerous();
}
```

Для реализации такого трэйта будет необходимо указать ключевое слово `unsafe`.

```rust
unsafe impl MyTrait for MyStruct {
    fn do_something_dangerous() {
        ...
    }
}
```

Тот факт что мы реализуем _unsafe_ трэйт, не означает что в методах мы обязательно используем `unsafe` блок. Unsafe трэйт может даже не содержать методово, как мы это увидим позже для трэйтов `Send` и `Sync`. Единственная цель с которой трэйт помечается как `unsafe` — сделать акцент на специфичнности трэйта тому, кто будет имплементировать этот трэйт для своего типа.
