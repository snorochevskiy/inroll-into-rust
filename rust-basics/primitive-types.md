# Примитивные типы данных

В языке Rust есть такие примитивные типы данных.

## Целочисленные

| Размер                                       | Знаковый | Беззнаковый |
| -------------------------------------------- | -------- | ----------- |
| 8 бит                                        | `i8`     | `u8`        |
| 16 бит                                       | `i16`    | `u16`       |
| 32 бита                                      | `i32`    | `u32`       |
| 64 бита                                      | `i64`    | `u64`       |
| 128 бат                                      | `i128`   | `u128`      |
| Платформозависимый (равный рамеру указателя) | `isize`  | `usize`     |

Тип числа можно указывать при помощи суфикса:

```rust
let a = 5u8; // указывает, что число 5 имеет тип u8
```

## С плавающей запятой

В Rust есть два типа с плавающей запятой: `f32` и `f64`. Соответственно их размер 32 и 64 бита.

Оба типа реализую стандарт IEEE-754,  то есть значения типов `f32` и `f64` могут хранить как вещественные типы, так и "бесконечность" и "не число".

```rust
let a: f32 = -1.0; // 1.0
let b = 5.0f32;    // 5.0
let c = a + b;     // 4.0
let d = 1.0 / 0.0; // inf
let e = a.sqrt();  // NaN
```

## bool

Булевый тип в Rust ровно такой, каким его можно ожидать: может хранить либо `true` либо `false` .

```rust
let a: bool = true;
let b = false;
```

Значение типа `bool` занимает в оперативной памяти 1 байт.

## Символы

В Rust есть отдельный тип для хранения отдельных текстовых символов - `char`. Фактически, это 4-байтное число, хранящее код символа в таблице Unicode.

В коде программы символ задаётся, как текстовый знак, взятый в одинарные кавычки.

```rust
let a = 'a';
let smile = '☺';
let book = '本';
```

## Unit

Тип Unit - аналог типа `void` в C, Java, и других им подобных языках. Как правило, он используется для обозначения типа результата в функциях, которые не возвращают какое-либо значение.

Хоть тип и называется "Unit", в коде он обозначается как `()` .

Принципиальное отличие Unit (множество синглтон) от void (пустое множество) заключается в том, что у типа Unit есть одно единственное значение. Мы можем даже создать переменную типа Unit и присвоить ей единственное возможное значение — `()` .

```rust
let a: () = ();
```

<details>

<summary>Чем не подходит void?</summary>

Тип Unit появился в языках, которые испытали на себе влияние функционального программирования. Дело в том, что в функциональном программировании, функция рассматривается, в первую очередь, как математическая функция, т.е. **отображение** значения из множества аргументов в значение из множества результатов. Здесь и появляется фундаментальная проблема типа `void`: это пустое множество, в котором нет значений. Это сильно усложняет моделирование системы типов для таких, важных в функциональном программировании, операций, как композиция функций.

В чисто функциональном языке Haskell даже есть фукция absurd, которая принимает аргумент типа Void и возвращает какое-то значение.

```haskell
absurd :: Void -> a
```

Какое это значение, и какого оно типа — не важно, так как эту функцию невозможно вызвать, ведь для её вызова необходим элемент из пустого множества, а такой не существует.

</details>

## Never type

Еще один интересный тип, обусловленный особенностями системы типов данных в языках, испытавших воздействие функционального программирования — never type.

В коде этот тип обозначается как `!`

Этот тип,  практически, никогда явно не указывается, и даже не наблюдается в коде. Более того, если не знать о его существовании, то можно годами писать на Rust, и даже не подозревать о его наличии.

На данном этапе мы пока что не сможем разобраться с этим типом. Скажем только, что компилятор используется этот тип, для выражений, которые никогда не возвращают значение в вызывающий код. Например, для функции выхода из программы.

Мы подробнее рассмотрим never type в главе [funkcii.md](funkcii.md "mention").

## Приведение типов

Для того, чтобы преобразовать один тип данных в другой используется оператор `as`.

Синтаксис:

```
значение as Тип
```

Пример:

```rust
fn main() {
    let a: i32 = 5;
    let b: i64 = a as i64;
    let c: i32 = b as i32;

    let d: f32 = 7.0;
    let e: i32 = d as i32;

    let f: bool = true;
    let g: i32 = f as i32; // 1
    let h = false as i32;  // 0

    let i = 'A' as i32; // 65
    let j = 66 as char; // B
}
```

Rust является языком со строгой типизацией, поэтому в нём отсутствуют неявные преобразования типов как в C. Любое преобразование типа нужно указывать явно при помощи оператора `as`.
