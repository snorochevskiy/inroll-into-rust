# Автоматическая реализация трэйтов

В качестве вводной давайте рассмотрим следующий пример. Мы попытаемся создать структуру для хранения координат точки в двухмерном пространстве, и попробуем сравнить два экземпляра точки на равенство:

{% code lineNumbers="true" %}
```rust
struct Point2D { x: i32, y: i32 }

fn main() {
  let p1 = Point2D {x: 1, y: 1};
  let p2 = Point2D {x: 1, y: 1};
  println!("p1 = p2: {}", p1 == p2);
}
```
{% endcode %}

При попытке скомпилировать этот код, мы получим ошибку:

```
error[E0369]: binary operation `==` cannot be applied to type `Point2D`
 --> src/my_module/num.rs:6:30
  |
6 |   println!("p1 = p2: {}", p1 == p2);
  |                           -- ^^ -- Point2D
  |                           |
  |                           Point2D
```

В ошибке компилятор указывает, что для того чтобы иметь возможность сравнивать объекты на равенство, их тип должен реализовывать трэйт [**PartialEq**](https://doc.rust-lang.org/std/cmp/trait.PartialEq.html), который предоставляет метод для сравнению двух экземпляров на равенство.

{% hint style="info" %}
Пусть вас не смущает, что трэйт называется "Partial Equals" (частично равенство): он используется именно для сравнению на равенство, а эта самая "частичность" задествуется только для редких случаев, например, сравнение двух `float`, короторые оба равны `NaN`: спецификация IEEE-754 требует, чтобы результат сравнения двух `NaN` был ложным, не смотря на то, что они одинаковые
{% endhint %}

Трэйт `PartialEq` имеет следующий вид (на самом деле он немного сложнее, но суть мы передали):

```rust
pub trait PartialEq {
    fn eq(&self, other: &Rhs) -> bool;
    fn ne(&self, other: &Rhs) -> bool { !self.eq(other) }
}
```

Как мы видим, трэйт содержит два метода: `eq` (equal) и `ne` (not equal). Когда компилятор встречает сравнение двух объектов при помощи оператор `==`, он подменяет использование оператора `==` на вызов метода `eq`. То есть, вызов `p1 == p2` будет заменён на `p1.eq(p2)`. Аналогично, применение оператора `!=`  заменяется на вызов метода `ne`.

Таким образом, чтобы проверка на равенство работала для нашей структуры `Point2D`, мы должны написать примерно такое:

```rust
struct Point2D { x: i32, y: i32 }

impl PartialEq for Point2D {
    fn eq(&self, other: &Self) -> bool {
        self.x == other.x && self.y == other.y
    }
}

fn main() {
  let p1 = Point2D {x: 1, y: 1};
  let p2 = Point2D {x: 1, y: 1};
  println!("p1 = p2: {}", p1 == p2);
}
```

Теперь всё работает.

Если мы задумаемся о реализации метода `ne` для нашей точки, который заключается просто в сравнении всех полей, то заметим, что для подавляющего большинства стрктур, которые мы можем написать, сравнение так же будет заключаться просто в сравнении между собой всех соответствующих полей.

К счастью, в Rust есть специальный механизм, который позволяет генерировать вот такие наиболее часты реализации для трэйтов  — аннотация `derive`.

## derive

Если над нашей структурой мы "повесим" аннотацию `#[derive(PartialEq)]`, то компилятор сам сгенерирует реализацию `PartialEq` для нашего типа. И эта реализаця будет заключаться как раз в сравнении всех поответствующих полей:

```rust
#[derive(PartialEq)]
struct Point2D { x: i32, y: i32 }

fn main() {
  let p1 = Point2D {x: 1, y: 1};
  let p2 = Point2D {x: 1, y: 1};
  println!("p1 = p2: {}", p1 == p2);

  let p3 = Point2D {x: 0, y: 0};
  let p4 = Point2D {x: 1, y: 1};
  println!("p3 = p4: {}", p3 == p4);
}
```

Как видим, так тоже всё работает, но наш код стал куда короче и выразительнее.

{% hint style="info" %}
Посмотреть код реализации через аннотацию derive можно при помощи утилиты cargo expand.
{% endhint %}

## Аннотации

Аннотация — это специальная пометка для компилятора, которой может быть отмечена структура, функция, модуль и т.д.

Аннотация имеет синтаксис:

```
#[аннотация(аргументы аннотации)]
```

Когда компилятор встречает аннотацию, он обращается к соответствующему обработчику, который выполняет ту или иную кодогенерацию.

Соответственно, для аннотации `derive` в стандартной библиотеке Rust, имеется специальный обработчик, который во время компиляции может выполнять генерацию стандартной реализаций для некоторых трейтов.

Кроме, `PartialEq`, генерация стандартной реализации поддерживается для целого ряд других трэйтов из стандартной библиотеки, например:

* [**Hash**](https://doc.rust-lang.org/std/hash/trait.Hash.html) – стандартный трэйт высчитывающий хеш код из объекта.
* [**Debug**](https://doc.rust-lang.org/std/fmt/trait.Debug.html) – трэйт который декларирует "отладочный" метод преобразования в строку. Именно он используется, когда мы распечатываем объект через `{:?}` в вызове `println!`.
* [**Default**](https://doc.rust-lang.org/std/default/trait.Default.html) - позволяет создавать дефолтное значение для типа: `0` - для чисел, `false` - для булевого типа, пустая строка - для строк, и т.д.

## трэйт Clone

Мы уже знаем, что благодаря концепции владения, при присваивании объекта от одной переменной к другой, это объект перемещается.

Однако, если мы хотим не перемещать объект, а скопировать, то нам на помощь придёт трэйт [**Clone**](https://doc.rust-lang.org/std/clone/trait.Clone.html), который предоставляет для этого метод `clone()`. Сам трэйт выглядит вот так:

```rust
trait Clone: Sized {
    fn clone(&self) -> Self;
}
```

Казалось бы, что в нём особенного? Мы и сами можем написать для нашего типа метод, который будет возвращаться копию объекта. Однако вся прелесть в том, что для `Clone`, так же можно сгенерировать реализацию просто путём добавления аннотации `derive`.

```rust
#[derive(Debug,Clone)]
struct Point2D { x: i32, y: i32 }

fn main() {
    let p1 = Point2D { x: 1, y: 1};
    let p2 = p1.clone();

    println!("p1={:?}, p2={:?}", p1, p2);
   // Напечатает: p1=Point2D { x: 1, y: 1 }, p2=Point2D { x: 1, y: 1 }
}
```

Разумеется, при необходимости, ничто не мешает нам реализовать `Clone` для нашего типа вручную.

```rust
#[derive(Debug)]
struct Point2D { x: i32, y: i32 }

impl Clone for Point2D {
    fn clone(&self) -> Point2D {
        Point2D {x: self.x, y: self.y}
    }
}

fn main() {
    let p1 = Point2D { x: 1, y: 1};
    let p2 = p1.clone();
    println!("p1={:?}, p2={:?}", p1, p2);
}
```

Реализация `clone()` сгенерированная при помощи `#[derive(Clone)]` делает глубокую копию объекта, т.е. текущий объект и всё вложенные. Именно поэтому, если мы хотим применить `#[derive(Clone)]` для нашей структуры, то типы всех полей этой структуры так же должны реализовать трэйт `Clone`.

## трэйт Copy

Из главы [ownership.md](ownership.md "mention") мы знаем, что при присвоении, перемещение происходит только для составных типов, а значения примитивных типов просто копируются.

На самом деле для того, чтобы понять нужно ли копировать объект или перемещать, компилятор проверяет реализует ли этот тип трэйт [**Copy**](https://doc.rust-lang.org/std/marker/trait.Copy.html).&#x20;

```rust
trait Copy: Clone { }
```

Как мы видим этот трэйт наследует трэйт `Clone`, но не добавляет никаких новых методов. Такие трэйты называются маркерными, т.е. просто играют роль "пометки" для компилятора.

Перепишем наш пример для структуры `Point2D`, но теперь к derive трэйтам добавим еще и `Copy`.

```rust
#[derive(Debug,Clone,Copy)]
struct Point2D { x: i32, y: i32 }

fn main() {
  let p1 = Point2D { x: 1, y: 1};
  let p2 = p1; // При присваивании вызывается p1.clone()

  println!("p1={:?}, p2={:?}", p1, p2);
  // p1=Point2D { x: 1, y: 1 }, p2=Point2D { x: 1, y: 1 }
}
```

Теперь при присваивании переменной `p1` в переменную `p2`, перемещение владения не происходит. Вместо этого создаётся копия объекта из переменной `p1`, и присваивается переменной `p2`.
