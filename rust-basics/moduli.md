# Модули

Для избежания конфликтов имён, а так же для логического структурирования кода, в программах на Rust принято группировать типы данных и функци в модули.

Модули являются аналогами пространств имен из C++, или пакетов из Java.

Есть несколько способов объвить модуль.

## Способ 1: mod { ... }

Модуль можно объявить прямо в `main.rs` при помощи ключевого слова `mod`.

```rust
mod имя_модуля {
    содержимое
}
```

Далее, чтобы обратиться к имени (функции или структуре) из модуля используется синтаксис:

```
модуль::имя
```

Пример решения конфликта имён при помощи модулей.

{% code title="main.rs" %}
```rust
mod a {
    pub fn get_num() -> i32 {
        1
    }
}

mod b {
    pub fn get_num() -> i32 {
        2
    }
}

fn main() {
    println!("{}", a::get_num()); // 1
    println!("{}", b::get_num()); // 2
}
```
{% endcode %}

Обратите внимание, что перед объявлением функции стоит модификатор видимости `pub` (public). Он указывает, что функция может быть использована "внешним" кодом. По умолчанию всё содержимое модуля является приватным, и может быть использовано только внутри этого модуля.

```rust
mod my_module {
    pub fn get_num() -> i32 {
        get_5()
    }
    fn get_5() -> i32 {
        5
    }
}

fn main() {
    println!("{}", my_module::get_num()); // 5
}
```

Такой способ создания модуля подходит просто для создания отдельного пространства имён внутри файла.

## Способ 2: другой \*.rs файл

Если создать другой файл с расширением `*.rs` в той же директории, что и `main.rs`, то этот файл можно будет подключить как модуль.

Например, допустим мы создали такой лэйаут файлов:

<img src="../.gitbook/assets/file.excalidraw (1) (1) (1) (1) (1) (1).svg" alt="" class="gitbook-drawing">

При компиляции файла `main.rs`, так же будет подключен и скомпилирован и `my_module.rs`.

```
$ rustc main.rs
$ ./main
5
```

Такой способ создания модуля подходит, когда весь код модуля можно поместесть в один файл.

## Способ 3: директория и mod.rs

Этот способ используется, когда функциональность модуля хорошо гранулирована и может быть разделена на несколько файлов:

<img src="../.gitbook/assets/file.excalidraw (1) (1) (1) (1) (1).svg" alt="" class="gitbook-drawing">

При компиляции `main.rs`, компилятор так же соберёт все подключённые модули.

```
$ rustc main.rs
$ ./main
7
```

## Трансляция и модули

Как вы могли заметить, когда мы создаём модули в виде отдельных файлов, нам не приходится компилировать их отдельно. Мы вызываем `rustc` только для `main.rs` файла, и все модули компилируются автоматически.

Сборку бинарного исполняемого файла можно проиллюстрировать так:

<img src="../.gitbook/assets/file.excalidraw (3).svg" alt="" class="gitbook-drawing">

Для сравнения, в C++ каждый `*.cpp` файл компилируется в отдельный объектный файл, и только потом все объектные файлы линкуются в исполняемый бинарный файл.

<img src="../.gitbook/assets/file.excalidraw (1) (1).svg" alt="" class="gitbook-drawing">

Сильно упрощая, можно сказать, что компилятор Rust "склеивает" `main.rs` и все входящие в него модули в один большой файл и компилирует его целиком.

Поэтому `main.rs` и все входящие в него модули называют **крэйтом** (crate — ящик).

Понятие крэйта, очень важно в экосистеме Rust. Мы подробнее поговорил про крэйты, и другие составляющие програм на Rust в главе [multiple-bin.md](../project/multiple-bin.md "mention").
