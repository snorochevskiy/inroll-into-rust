# Создание библиотеки

Разберёмся теперь как создавать библиотеки

<pre><code><strong>cargo new my_lib --lib
</strong></code></pre>

Флаг `--lib` указывает, что изначально вместо `src/main.rs` надо создать `src/lib.rs`.

```
├── Cargo.toml
└── src/
    └── lib.rs
```

(На самом деле, ничто не мешает иметь и `src/main.rs` и `src/lib.rs` одновременно)

Теперь в `Cargo.toml` в секции `[package]` нам надо указать какой тип библиотеки будет представлять из себя наш крэйт. Для этого используется поле `crate-type`:

```toml
[package]
name = "my_lib"
version = "0.1.0"
edition = "2024"

[lib]
crate-type = ["lib"]

[dependencies]
```

Для `crate-type` доступны такие варианты:

* **`lib`** — Библиотека для программы на Rust. Такой крэйт может становится разным типом библиотеки, в зависимости от того, как бкдет собираться программа, которая его использует. Единственное что гарантируется: этот крейт будет работоспособен для любого другого Rust проекта.
* **`rlib`** — Статическая библиотека, специфичная для програм на Rust. Представлена файлом с расширением `*.rlib`.
* **`dylib`** — Динамическая библиотека (`*.dll` на Windows, `*.so` на Linux, `*.dylib` на MacOS), которая подходит только для програм на Rust
* **`cdylib`** — Системная динамическая библиотека, которая может быть использована из програм на других языках
* **`staticlib`** — Статическая библиотека (`*.a` или `*.lib`). Подходит для статической линковки в программу на языке отличном от Rust.
* **`proc-macro`** — Библиотека содержащая процедурный макрос.

Как видно, в общем случае, при разработке библиотеки для Rust приложений, оптимальным вариантом является `crate-type=["lib"]`.

Осталось написать сам код нашей библиотеки — `src/lib.rs`. Для наших нужд подойдёт, что угодно: например, фунция складывающая два числа:

```rust
pub fn sum2(a: i32, b: i32) -> i32 {
    a + b
}
```

## Использование бибилотеки

Как мы знаем, когда мы указываем бибилиотеку в секции `[dependencies]` в `Cargo.toml`, то Cargo пытается найти соответствующий крэйт на crates.io.

Однако, Cargo умеет скачивать зависимости не только с crates.io, но и из:

*   git репозиториев

    ```toml
    [dependencies]
    крэйт = { git = "https://github.com/аккаунт/репозиторий.git", branch = "main" }
    ```
*   локальной файловой системы

    ```toml
    [dependencies]
    крэйт = { path = "/путь/к/коду/" }
    ```
*   альтернативных репозиториев крэйтов

    ```toml
    [dependencies]
    крэйт = { version = "1.0", registry = "репозиторий" }
    ```

В том же каталоге, где находится `my_lib`, создадим новый проект, который подключит нашу библиотеку в качестве зависимости расположеной на локальной файловой системе.

<pre><code><strong>cargo new lib_usage --bin
</strong></code></pre>

Теперь укажем папку `my_lib` в качестве местарасположения для зависимости `my_lib`.

```toml
[package]
name = "lib_usage"
version = "0.1.0"
edition = "2024"

[dependencies]
my_lib = { path = "../my_lib" }
```

Теперь в `src/main` сделаем простейший пример использования нашей библиотеки.

```rust
use my_lib::sum2;

fn main() {
    println!("sum2(1,2)={}", sum2(1, 1));
}
```

И запустим:

```
lib_usage$ cargo run
     Locking 1 package to latest Rust 1.89.0 compatible version
   Compiling my_lib v0.1.0 (/home/user/projects/rust/my_lib)
   Compiling lib_usage v0.1.0 (/home/user/projects/rust/lib_usage)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s
     Running `target/debug/lib_usage`
sum2(1,2)=2
```

В логах сборки можно увидеть,  как сначала компилируется зависимость `my_lib`, и затем уже непосредственно наше приложение.

## main.rs в библиотеке

Мы можем иметь одновременно и `src/main.rs` и `src/lib.rs` одновременно. Это удобно, когда мы поставляем и библиотеку, и программу, которая использует функциональностью из этой библиотеки.

Взглянем, например, на один из самых известных проектов FFmpeg — (написан на C/C++). Он содержит библиотеку libffmpeg, которая предоставляет функциональность для декодиторования и редактирования аудио и видео файлов. Эта библиотека используется множеством различных програм, включая даже такие гиганты как Google Chrome. Но в репозитории FFmpeg так же имеется консольная утилита ffmpeg, которая по сути является консольным интерфейсом для libffmpeg.

Для подобных случаев удобно иметь одновременно и `lib.rs` и `main.rs`: первый для функциональности, а второй для программы, которая эту функциональность использует.

При этом `lib.rs` и `main.rs` будут жить отдельно друг от друга, как если бы это была отдельно библиотека, и отдельно точно такой же проект, но с программой вместо библиотеки (за исключением, если мы подключим `lib` как модуль в `main.rs`):

```rust
mod lib;

fn main() {
    lib::something();
}
```
