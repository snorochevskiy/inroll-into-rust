# Структуры

Одним из представителей составных типов в Rust являются структуры.

**Структура** - именованный набор поле различного типа, который составляет новый тип данных.

Синтаксис объявления структуры следующий:

```rust
struct ИмяСтруктуры {
    поле_1: Тип1,
    поле_2: Тип2,
    ...
    поле_N: ТипN,
}
```

Заметте, что после последнего поля структуры, как и после последнего аргумента при объявлении функции, можно ставить запятую.

Поля структуры, как и переменные, должны именоваться в соответствии со змеинной нотацией. Имена структуры должны следовать Паскалевской нотации (Pascal case): имя начинается с заглавной буквы, и если в названии присутствует несколько слов, то каждое слово так же начинается с заглавной буквы. Например: User, MainAddress, DatabaseConnection.

Пример структуры, которая хранит имя и фамилию человека:

```rust
struct Person {
    first_name: String,
    last_name: String,
}
```

Синтаксис создания экземпляра структуры:

```rust
let переменная = ИмяСтруктуры { поле_1: значение_1,  ..., поле_N: значение_N};
```

Например:

```rust
let person = Person {
    fists_name: String::from("John"),
    last_name: String::from("Doe"),
};
```

Доступ к полю структуры осуществляется при помощи точки: `структура.поле`.

```
my_struct.field_1
```

Рассмотрим пример:

```rust
struct Person {
    first_name: String,
    last_name: String,
}

fn get_full_name(p: &Person) -> String {
    format!("{} {}", p.first_name, p.last_name)
}

fn main() {
    let p = Person {
        first_name: "John".to_string(),
        last_name: "Doe".to_string()
    };
    let full_name = get_full_name(&p);
    println!("{}", full_name); // "John Doe"
}
```

Если мы инициализируем поле структуры из переменной, чьё имя совпадает с именем структуры, то вместо `имя_поля: имя_переменной`, можно просто указать переменную.

```rust
let fists_name = String::from("John");
let person = Person {
    fists_name,
    last_name: String::from("Doe"),
};
```

Чтобы иметь возможность изменять значения полей у переменной типа структуры, вся переменная должна быть объявлена как мутабельная.

```rust
fn main() {
    let mut p = Person {
        first_name: "John".to_string(),
        last_name: "Doe".to_string()
    };
    p.firs_name = "Theodor".to_string();
}
```

## Копирование структуры



```
let p1 = Person {
    first_name: "John".to_string(),
    last_name: "Doe".to_string()
};

let p2 = Person { first_name: "Robert", ..p1};

println!("{} {}", p2.first_name, p2.last_name);
```



## Методы

В отличии от традиционных ООП языков, где методы объявляются в тебе класса, в Rust методы структуры объявляются отдельно от неё.

Синтаксис:

```rust
impl ИмяСтруктуры {

  // метод, который НЕ меняет вызывающий объект
  fn метод_1(&self, аргумент_1: Тип1, …, аргумент_N: ТипN) -> ТипРезультата {
    ...
  }

  // метод, который меняет вызывающий объект
  fn метод_2(&mut self, аргумент_1: Тип1, …, аргумент_N: ТипN) -> ТипРезультата {
    ...
  }

  // "статический" метод, вызываемый на структуре, а не на объекте структуры
  fn метод_3(аргумент_1: Тип1, …, аргумент_N: ТипN) -> ТипРезультата {
    ...
  }
}
```

Аналогом ключевого слова this из C++ и Java, является `self`, которое надо явно передавать в качесве первого аргумента метода.

* Если метод не меняет состояние объекта, на котором он вызван, то _self_ можно передавать по немутабельной ссылке - `&self` .
* Если же же методу необходимо изменять хотя бы одно из полей структуры, но _self_ необходимо передавать по мутабельной ссылке - `&mut self`.
* В редких случаях, когда метод должен забрать во владение объект, на котором он был вызван, _self_ стоит передавать по значению - `self`.

Пример:

```rust
struct Person {
  first_name: String,
  last_name: String,
  age: u32
}

impl Person {
  fn new(first: &str, last: &str) -> Person {
    Person {
      first_name: first.to_string(),
      last_name: last.to_string(),
      age: 0
    }
  }
	
  fn change_age(&mut self, new_age: u32) {
    self.age = new_age;
  }
	
  fn introduce(&self) -> String {
    format!("{} {} is {} years old", self.first_name, self.last_name, self.age)
  }
}

fn main() {
  let mut p = Person::new("John", "Doe");
  p.change_age(25);
  println!("{}", p.introduce());
}
```

## Кортежные структуры (tuple structs)

В дополнение к традиционным структурам, которые являются коллекцией именованных полей, Rust предлагает, так называемые, **кортежные структуры**, где поля идентифицируются не именем, а позицией.

Синтаксис:

```rust
struct Имя(Тип1, Тип2, …, ТипN)
```

Пример:

```rust
/// Представляет цвет закодированный RGB каналами
struct RGB (u8, u8, u8);

impl RGB {
    /// Упаковывает все 3 канала в одной 4-байтное число
    fn as_u32(&self) -> u32 {
        ((self.0 as u32) << 16)
            + ((self.1 as u32) << 8)
            + (self.2 as u32)
    }
}

fn main() {
    let mut color: RGB = RGB(255, 0, 0);  // красный цвет
    println!("Red channel: {}", color.0); // Red канал: 255

    color.1 = 255; // Выставляет зелёный канал в 255

    // кортежную структуру можно разложить на составляющие
    // так же как и обычный кортеж
    let RGB(r, g, b) = color;

    println!("R={r}, G={g}, B={b}"); // R=255, G=255, B=0

    println!("As number: {}", color.as_u32());
}
```

Как видим, кортежная структура - это фактически обычный кортеж, только с осмысленным именем, и возможностью добавить к ней дополнительные методы.

## Структуры синглтоны

TODO
