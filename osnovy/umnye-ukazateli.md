# Умные указатели

До этого момента, явно мы работали только с данными, размещаемыми на стаке. Мы, конечно, рассмотрели много примеров с векторами и строками, которые хранят свои элементы в куче, однако эти типы инкапсулируют работу с кучей в себе, полностью скрывая её от нас. В этой же главе мы явно разберём работу с чучей при помощи умных указателей.

{% hint style="info" %}
Умный указатель (smart pointer) — термин пришедший из C++, где в отличии от C, в котором указатель является просто ячейкой хранящей в себе адресс, умный указатель представляет из себя класс, который не просто предоставляет доступ к данным по адресу, но и умеет автоматически очищать память при исчезновении умного указателя на неё.
{% endhint %}

## Box

Первым указателем, который мы рассмотрим является [**Box**](https://doc.rust-lang.org/std/boxed/struct.Box.html). Мы уже вскольз упоминали его в разделе [#vozvrat-treita-iz-funkcii](treity.md#vozvrat-treita-iz-funkcii "mention").

`Box<T>` - это обобщённый тип, который хранит адрес значения тип `T`, размещённого в куче в куче. `Box` является владельцем данных в куче, т.е. при выходе переменной `Box` из скоупа, происходит автоматическая освобождения соответствующей памяти в куче.

{% hint style="info" %}
Проводя аналогию с C++, `Box` является прямым аналогом умного указателя `unique_ptr`.
{% endhint %}

С точки зрения лэйату в памяти, Box является так называемой "zero cost abstraction". То есть представляет из себя просто ячейку с адресом, которая располагается на стеке, и не более.

<img src="../.gitbook/assets/file.excalidraw (4).svg" alt="" class="gitbook-drawing">

Наиболее просто способ создать `Box` — метод-конструктор `Box::new(T)`, который принимает в качестве аргумента значение, и переносит это значение на кучу. Рассмотрим пример:

```rust
// Структура для хранения координат точки в двухмерном пространстве
struct Point2D { x: i32, y: i32 }

fn main() {
    let p: Point2D = Point2D {x: 5, y: 2}; // Создаём значение на стеке
    let b: Box<Point2D> = Box::new(p);     // Перемещаем значение в кучу
}
```

Чем нам может быть полезно такое хранение значений в куче? Дело в том, что для того, чтобы значение можно было хранить на стеке, его размер должен быть известен во время компиляции, как например, с этой структурой `Point2D`: значение всегда будет одинаковым (два поля размером `i32`). Однако полный размер таких структур как вектор не известен на этапе компиляции, так как количество элементов вектора не известно.

Для наглядности, давайте напишем классическую структуру данных — односвязанный список.

<img src="../.gitbook/assets/file.excalidraw (16).svg" alt="" class="gitbook-drawing">

На первый взгляд, эту конструкцию можно было бы описать так:

```rust
// Список — это:
enum List<T> {
    Nil,              // либо пустой список
    Elem(T, List<T>), // либо пара: значение + список
}
```

Однаком компилятор выдаст такую ошибку:

```rust
enum List<T> {
    Nil,
    Elem(T, List<T>),
}           ------- recursive without indirection
// error[E0072]: recursive type `List` has infinite size
// insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle
//   Elem(T, Box<List<T>>),
//           ++++       +
```

Это как раз то, о чём мы говорили раньше: рекурсивная структура имеет неопределённый размер, что делает невозможным её размещение на стеке. Компилятор любезно предлагает использовать нам `Box`, что как раз решит проблему:

```rust
#[derive(Debug)]
enum List<T> {
    Nil,
    Elem(T, Box<List<T>>),
}

use List::*;

fn main() {
    let list: List<i32> =
        Elem(1, Box::new(
            Elem(2, Box::new(
                Elem(3, Box::new(Nil))
        ))));
    println!("{:?}", list); // Elem(1, Elem(2, Elem(3, Nil)))
}
```

## Трэйты Deref и DerefMut

`Box` позволяет использовать оператор `*` для разыменовывание бокса, словно это сслыка. Так же при помощи оператора `&` из бокса можно получить прямую ссылку на данные в куче.

```rust
fn main() {
    let mut b = Box::new(1);
    *b = 2;
    println!("{b}"); // 2

    increment(&mut b);
    println!("{b}"); // 3
}

fn increment(i: &mut i32) {
    *i += 1;
}
```

Такое поведение бокса (словно он ссылка) возможно благодаря тому, что `Box` реализует трэйт [**Deref**](https://doc.rust-lang.org/std/ops/trait.Deref.html).

```rust
pub trait Deref {
    type Target: ?Sized;
    fn deref(&self) -> &Self::Target;
}
```

Этот трэйт позволяет типу предоставлять некую ссылку. Разумеется, в случае с `Box`, это ссылка на данные в куче.

Если тип реализует трэйт `Deref`, то для его объектов компилятор подменяет `&объект` на `объект.defer()`.

Как мы могли заметить, метод `deref` возвращает немутабельную ссылку. Для случаев, когда мы хотим иметь возможность изменять значение по ссылке, существует трэйт [**DerefMut**](https://doc.rust-lang.org/std/ops/trait.DerefMut.html).

```rust
pub trait DerefMut: Deref {
    fn deref_mut(&mut self) -> &mut Self::Target;
}
```

Вызов `*объект=значение` подменяется на `*(объект.deref_mut())=значение`.

## Rc - совместное владение

Концепция владения Rust не позволяет совместное владение одним и тем же объектом, однако есть целый ряд структур данных, где это необходимо (например, двусвязанный список). Для таких ситуация стандартная библиотека Rust предоставляет умный указатель [**Rc**](https://doc.rust-lang.org/std/rc/struct.Rc.html).

В отличии от `Box<T>`, который по сути представляет из себя просто указатель на данные в куче, `Rc<T>` — структура из двух полей: указатель на данные в куче и указатель на счётчик копий объекта `Rc`.

```rust
use std::rc::Rc;

fn main() {
    let mut rc1 = Rc::new("Hello");
    let mut rc2 = rc1.clone();
}
```

Когда мы создаём новый объект при помощи `Rc::new(значение)`

1. На стеке создаётся объект стуктуры `Rc`
2. На куче выделяется место для данных, и в него переносится значение переданное в `Rc::new()`. Адрес значения в куче присваивается полю-указателю на данные в объекте `Rc`.
3. На куче выделяется место под счётчик копий `Rc` и инициализируется единицей. Адрес этого счётчика присваивается полю-указателю на счётчик в объекте `Rc`.

Когда мы слонируем объект `Rc`:

1. На стеке создаётся создаётся новый объект `Rc`.
2. Значение указателя на данные копируется из клонируемого объекта `Rc`.
3. Значение указателя на счётчик числа копий `Rc` копируется из клонируемого объекта `Rc`, при этом сам счётчик инкрементируется.

Когда переменная, хранящая объект `Rc`, выходит из скоупа:

1. Счётчик копий `Rc` уменьшается на `1`.
2. Если при этом значение счётчика стало равным `0`, то память, в которой хранятся данные, и память, в которой хранится сам счётчик, очищаются.

<img src="../.gitbook/assets/file.excalidraw (5).svg" alt="" class="gitbook-drawing">

{% hint style="info" %}
Проводя аналогию с C++, `Rc` является прямым аналогом умного указателя `shared_ptr`.
{% endhint %}

## Cell

Основное неудобство `Rc` заключается в том, что в отличии от `Box`, он не реализует трэйт `DerefMut`, что в свою очередь не позволяет менять его содержимое.

```rust
use std::rc::Rc;

fn main() {
    let mut rc1 = Rc::new(1);
    *rc1 += 1;
 // ^^^^^^^^^ cannot assign
 // trait `DerefMut` is required to modify through a dereference,
 // but it is not implemented for `Rc<i32>`
}
```

Почему так сделано? Давайте вспомнил правило безопасности ссылок в Rust [#bezopasnost-ssylok-referential-safety](vladenie.md#bezopasnost-ssylok-referential-safety "mention"): на объект одновременно можно иметь либо одну немутабельную ссылку, либо сколько угодно мутабельных. И само это правило обусловлено тем, что в общем случае без дополнительных механизмов синхронизации, нельзя гарантировать корректность немутабельной ссылки, после того как данные были изменены по мутабельной ссылке.

Именно поэтому `Rc` и позволяет множественное владение одним и тем же объектом (аналог множества немутабельных ссылок), но без возможнсти менять значение.

Как мы заметили выше, одновременное наличие немутабельно и мутабельной ссылок не безопасно БЕЗ дополнительных механизмов синхронизации. Стандартная библиотека Rust предлагает механизм синхронизации специльно для таких ситуаций — структура-обёртка [**Cell**](https://doc.rust-lang.org/std/cell/struct.Cell.html).

`Cell<T>` — обёртка, которая позволяет заменять своё содержимое целиком, безопасно и атомарно. При этом не позволяет получать мутабельную ссылку на своё содержимое, что предотвращает возможности "порчи данных", а так же не позволяет получать немутабельную ссылку, которая могла бы стать недействительной при замене значения в `Cell`.

```rust
use std::cell::Cell;

fn main() {
    let cell = Cell::new("aaa".to_string());

    // При замещении новым значение, прошлое возвращается как результат
    let old_string = cell.replace("bbb".to_string());
    println!("{old_string}");

    // Если нам не нужно прошлое значение, то можно просто перезаписать его новым.
    cell.set("ccc".to_string());
}
```

Обратите внимание: переменная `cell` объявлена без модификатора `mut`, однако мы смогли заместить хранящуюся в ней строку, другой строкой. Так происходит, потому что замена значения происходит атомарно и безопасно, поэтому переменной не обязательно иметь семантику мутабельности со всеми сопутствующими ограничениями.

Если тип реализует интерфейс `Copy`, то из `Cell` можно извлекать его копию методом `get`.

```rust
use std::cell::Cell;

fn main() {
    let cell = Cell::new(1);
    println!("{}", cell.get()); // c1 = 1
}
```

Теперь, используя комбинацию `Rc<Cell<T>>`, мы можем создавать структуры данных, которые требуют как совместное владение, так и возможность заменять хранимое значение.

```rust
use std::{cell::Cell, rc::Rc};

fn main() {
    let rc1 = Rc::new(Cell::new(1));
    let rc2 = rc1.clone();

    //  Получаем ссылку на разделяемый Cell и записываем в него новое значение
    rc2.as_ref().set(5);

    println!("{:?}", rc1); // Cell { value: 5 }
}
```

{% hint style="info" %}
Важно заметить, что Cell защищает только от сценариваем порчи немутабельной ссылки петём изменения данных через мутабельную ссылку в рамках одного потока. Какой либо защиты от гонок данных Cell не предоставляет.
{% endhint %}

## RefCell

Очевидным недостатком `Cell` является то, что он позволяет только заменять хранимое значение, но не модифицировать. Обёртка `RefCell<T>` позволяет как раз изменять хранимое значение по ссылке.

```rust
use std::cell::{RefCell, RefMut};

fn main() {
    let ref_cell = RefCell::new(1);
    {
        let mut mut_ref: RefMut<'_, i32> = ref_cell.borrow_mut();
        *mut_ref = 5;
    }
    println!("{:?}", ref_cell);
}
```

`RefCell` не нарушает правило безопасности ссылок, а просто переносит проверку из времени компиляции в рантайм. То есть, попытка получить одновременно мутабельную и мутабельную ссылкы на содержимое `RefCell` вызовет панику.

{% code lineNumbers="true" %}
```rust
use std::cell::{RefCell, RefMut, Ref};

fn main() {
    let ref_cell = RefCell::new(1);

    let immut_ref: Ref<'_, i32> = ref_cell.borrow(); // borrowing immutable

    let mut mut_ref: RefMut<'_, i32> = ref_cell.borrow_mut();
    *mut_ref = 5;                   // ^^^ already borrowed: BorrowMutError
    
    println!("{:?}", ref_cell);
}
```
{% endcode %}

Теперь, мы можем переписать наш односвязанный список с использование `RefCell`:

```rust
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
enum List<T> {
    Elem(Rc<RefCell<T>>, Rc<List<T>>),
    Nil,
}

use List::*;

fn main() {
    let v = Rc::new(RefCell::new(1));

    let a = Rc::new(Elem(Rc::clone(&v), Rc::new(Nil)));

    let b = Elem(Rc::new(RefCell::new(2)), Rc::clone(&a));
    let c = Elem(Rc::new(RefCell::new(3)), Rc::clone(&a));

    *v.borrow_mut() += 10;
    println!("a after = {:?}", a);
    // Elem(RefCell { value: 11 }, Nil)
    
    println!("b after = {:?}", b);
    // Elem(RefCell { value: 2 }, Elem(RefCell { value: 11 }, Nil))
    
    println!("c after = {:?}", c);
    // Elem(RefCell { value: 3 }, Elem(RefCell { value: 11 }, Nil))
}
```

## Arc

`Rc` позволяет совместное владением над объектом, однаком `Rc` не является потокобезопасным типое, то есть, не позволяет совместное владение объектом из разных потоков. Для многопоточной среды имеется потокобезопасная версия - `Arc`.

{% hint style="info" %}
Мы будем разбирать многопоточное программирование на Rust в главе [mnogopotochnost.md](../standartnaya-biblioteka/mnogopotochnost.md "mention"). Пока что можете не углубляться в нижеприведённый пример, а просто запомнить, что при многопточном программировании вместо `Rc` используется `Arc`.
{% endhint %}

```rust
use std::sync::{Arc, Mutex, MutexGuard};
use std::thread;

fn main() {
  let counter: Arc<Mutex<i32>> = Arc::new(Mutex::new(0));

  let mut threads = Vec::new();
  for _ in 0 .. 10 {
    let counter_clone = counter.clone();
    let t = thread::spawn(move || {
      for _ in 0 .. 50 {
        let mut mut_guard: MutexGuard<'_, i32> = counter_clone.lock().unwrap();
        *mut_guard += 1; // MutexGuard имеет семантику мутабельной ссылки
      } // MutexGuard выходит из скоупа, и разблокирует мьютекс
    });
    threads.push(t);
  }
  for t in threads {
    let _ = t.join();
  }
  println!("{:?}", counter);
}
```

## Cow

TODO
