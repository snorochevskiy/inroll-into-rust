# Паттерн матчинг

В дополнение в оператору if, в Rust есть еще один оператор ветвления, который мы не рассмотрели раньше - match.

Это оператор является неким гибридом классического switch-case и диструктурирующего присваивания, и его часто называют паттерн-матчингом (pattern matching).

Синтаксис:

```rust
match значение {
    шаблон 1 => выражение 1,
    …
    шаблон N => выражение N,
}
```

Оператор последовательно применяет шаблоны к значению: если шаблон совпадает, то выполняет соответствующее ему выражение, и выходит из тела оператора, иначе  переходит к следующему шаблону.

Шаблон может быть константой, переменной, переменной с условным блоком, или деструктурирующим присваиванием. Рассмотрим все варианты в порядке возрастания сложности.

## match как switch-case

Рассмотрим сначала самый простой пример, в котором оператор `match` используется как switch-case из C или Java.

Проверим равно ли значение числовой переменной нулю или единице:

```rust
fn main() {
    let a = 1;
    match a {
        0 => println!("The number is 0"),
        1 => println!("The number is 1"),
    }
    // Напечатает: The number is 1
}
```

Если значение переменной будет не равно 0 или 1, то ниодна из веток не будет выполнена, и ничего не будет напечатано на консоль.

Можно задать шаблон, который будет успешно совпадать с любым значение - шабло `_`. Поместив его в самом конце списка шаблонов, мы создадим подобие ветки else, которая отрабатывает в случае, если не отработала ниодна из предыдущих веток:

```rust
fn main() {
    let a = 5;
    match a {
        0 => println!("The number is 0"),
        1 => println!("The number is 1"),
        _ => println!("The number is not 0 or 1"), // вариант по умолчанию
    }
    // Напечатает: The number is not 0 or 1
}
```

Шаблон `_` - это на самом деле обычная "выброшенная" переменная, такая же как те, что мы видели в деструктурирующих шаблонов. Вместо "выброшенной" переменной можно указать переменную с любым корректным именем, и тогда в неё будет записано значение переданное в `match`. Имейте ввиду, что такой шаблон из просто переменной, подходит под любое значение, поэтому должен располаться в самом конце списка шаблонов.

```rust
fn main() {
    let a = 5;
    match a {
        0 => println!("The number is 0"),
        1 => println!("The number is 1"),
        x => println!("The number is {x}"),
    }
    // Напечатает: The number is 5
}
```

В шаблоне можно так же перечислить несколько значений:

```rust
fn main() {
    let a: u32 = 7;
    match a {
        0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 =>
            println!("The number is less than 10"),
        _ =>
            println!("The number is equal to or greater than 10"),
    }
    // Напечатает: The number is less than 10
}
```

Проверяя числа в шаблоне вместо того, чтобы перечислять подряд все значения, можно указать диапазон:

```rust
fn main() {
    let a: u32 = 44;
    match a {
        0 ..= 9 => // от 0 до 9включительно
            println!("The number is less than 10"),
        10 .. 100 => // от 10 до 100 не включительно
            println!("The number is in range [10,99]"),
        _ =>
            println!("The number is equal to or greater than"),
    }
    // Напечатает: The number is in range [10,99]
}
```

## Переменная привязка

В примере выше мы указали целый диапазон значений. Но что если мы хотим знать не только диапазон, но и конкретное значение? Можно конечно напрямую обратиться к переменной, передавнной в `match`, однако это не всегда возможно. Например, если в `match` было передано арифметическое выражение, или вызов функции.

В таком случае нам поможет **переменная привзяка** (binding). Это такая переменная, в которую записывается значение в той форме, в которой оно было передано в оператор `match`.

Синтаксит:

```
привязка @ шаблон => выражение
```

Теперь перепишем пример выше с использованием привязок:

```rust
fn main() {
    match 22 + 22 {
        x@(0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9) =>
            println!("{x} is less than 10"),
        x@10 .. 100 =>
            println!("{x} is in range [10,99]"),
        x =>
            println!("{x} is equal to or greater than"),
    }
    // Напечатает: 44 is in range [10,99]
}
```

## match выражение

Оператор `match`, как и оператор `if` возвращает значение. Результат всего оператора `match` - результат отработавшей условной ветки.

Пример оператора `match`, который используется для получения модуля числа (неотрицательной части):

```rust
let a = -5;
let absolute = match a {
  .. 0 => -a, // диапазон от минус бесконечности до 0 невключительно
  _ =>     a,    
};
println!("{absolute}"); // 5
```

## Сравнение со строковыми литералами

В случае если у нас имеется строка `String`, и мы хотим сравнивать её с со строковыми литералами в шаблонах, нам не удасться передать строку `String` в оператор `match` непосредственно, так как строковые литералы в шаблонах будут иметь тип `&str`.

Для того, чтобы сравнивать `String` со строковыми литаралами `&str` в шаблонах, следует просто получить слайс `&str` на строку из объекта `String`:

```rust
fn main() {
    let name = String::from("Robert Smith");
    let is_anonymous = match name.as_str() {
        "Anonymous" | "John Doe" => true,
        _                        => false,
    };
}
```

## match для слайсов

Для слайсов можно использоваться шаблоны, которые выглядят точно как шаблоны деструктурирующего присваивания для массивов.

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];

    let s = match v.as_slice() {
        []            => 0,
        [a, b, c, ..] => a + b + c,
        _             => -1,
    };

    println!("{}", s); // 6
}
```

В отличии от деструктурирующего присваивания, где деструктурирующий шаблон должен обязательно совпадать с типом деструктурируемого значения, в match выражении если шаблон не получится сопоставить со значением, то эта услованя ветка будет отброшена, и сопоставление будет произведено для следующего по списку шаблона.

Именно поэтому слайсы нельзя использовать в деструктурирующем присвании, но можно использовать в паттерн матчинге.

## match для структур

Синтаксис шаблонов для структур в паттерн-матчинге очень похож на синтаксис шаблонов для деструктурирующего присваивания, однако позволяет дополнительно задавать значения для полей.

```rust
struct Person { name: String, age: u32 }

fn main () {
    let p = Person { name: String::from("John"), age: 17 };
    match p {
        Person { name, age: 1 .. 18 } => println!("Person {name} is not adult"),
        Person { name, age: 18 }      => println!("Person {name} just turned 18"),
        Person { name, .. }           => println!("Person {name} is adult"),
    }
    // Напечатает: Person John is not adult
}
```

## match if

В шаблонах можно указывать дополнительное условие при помощи ключевого слова if.

```rust
struct Person { name: String, age: u32 }

fn main () {
    let p = Person { name: String::from("John"), age: 17 };
    match p {
        Person { name, age } if age < 18 =>
            println!("Person {name} is not adult"),
        Person { name, age } if age == 18 =>
            println!("Person {name} just turned 18"),
        Person { name, .. } =>
            println!("Person {name} is adult"),
    }
    // Напечатает: Person John is not adult
}
```

Условие в блоке if может быть сколь угодно сложным, и образаться к полям шаблона, а так же биндингам.

## ref

Если в шаблоне нужно "захватить" поле структуры по ссылке, а не по значению, то перед полем нужно указать ключевое слово `ref`.

Пример: при помощи паттерн матчинга, если у объекта типа `Person` поле `name` содержит строку "Anonymous", мы заменяет имя на "John Doe".

```rust
#[derive(Debug)]
struct Person { name: String, age: u32 }

fn main () {
    let mut p = Person { name: String::from("Anonymous"), age: 25 };
    match p {
        Person { ref mut name, .. } if name == "Anonymous" => {
            *name = "John Doe".to_string();
        },
        Person { .. } => (),
    }
    println!("{p:?}"); // Person { name: "John Doe", age: 17 }
}
```
