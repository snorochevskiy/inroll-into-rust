# Паттерн матчинг

В дополнение в оператору `if`, в Rust есть еще один оператор ветвления, который мы не рассмотрели раньше — `match`.

Этот оператор является неким гибридом классического switch-case и деструктурирующего присваивания, и его часто называют паттерн-матчингом (pattern matching).

Синтаксис:

```rust
match значение {
    шаблон 1 => выражение 1,
    …
    шаблон N => выражение N,
}
```

Оператор последовательно примеряет шаблоны к значению: если шаблон совпадает, то выполняется соответствующее ему выражение, и оператор `match` завершает свою работу, иначе  происходит проверка следующего по списку шаблона.

Шаблон может быть константой, переменной, переменной с условным блоком, или деструктурирующим присваиванием. Рассмотрим все варианты в порядке возрастания сложности.

## match как switch-case

Самый просто вариант использования оператора `match` — используется как switch-case из C или Java.

В качестве примера, проверим равно ли значение числовой переменной нулю или единице:

```rust
fn main() {
    let a = 1;
    match a {
        0 => println!("The number is 0"),
        1 => println!("The number is 1"),
    }
    // Напечатает: The number is 1
}
```

Если значение переменной будет не равно `0` или `1`, то ниодна из веток не будет выполнена, и на консоль ничего не будет напечатано.

Так же,  можно задать шаблон, который будет успешно совпадать с любым значение — шаблон `_`. Поместив его в самом конце списка шаблонов, мы создадим подобие ветки else, которая отрабатывает в случае, если не отработала ниодна из предыдущих веток:

```rust
fn main() {
    let a = 5;
    match a {
        0 => println!("The number is 0"),
        1 => println!("The number is 1"),
        _ => println!("The number is not 0 or 1"), // вариант по умолчанию
    }
    // Напечатает: The number is not 0 or 1
}
```

Шаблон `_` — это обычная "выброшенная" переменная, такая же как те, что мы видели в деструктурирующих шаблонов.

Вместо "выброшенной" переменной можно указать переменную с любым корректным именем, и тогда в неё будет записано значение переданное в `match`. Имейте ввиду, что такой шаблон в виде переменной, подходит под любое значение, поэтому должен располаться в самом конце списка шаблонов.

```rust
fn main() {
    let a = 5;
    match a {
        0 => println!("The number is 0"),
        1 => println!("The number is 1"),
        x => println!("The number is {x}"),
    }
    // Напечатает: The number is 5
}
```

В шаблоне можно так же перечислить несколько значений:

```rust
fn main() {
    let a: u32 = 7;
    match a {
        0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 =>
            println!("The number is less than 10"),
        _ =>
            println!("The number is equal to or greater than 10"),
    }
    // Напечатает: The number is less than 10
}
```

Проверяя числа в шаблоне, вместо того, чтобы перечислять подряд все значения, можно указать диапазон:

```rust
fn main() {
    let a: u32 = 44;
    match a {
        0 ..= 9 => // от 0 до 9включительно
            println!("The number is less than 10"),
        10 .. 100 => // от 10 до 100 не включительно
            println!("The number is in range [10,99]"),
        _ =>
            println!("The number is equal to or greater than"),
    }
    // Напечатает: The number is in range [10,99]
}
```

## Переменная привязка

В примере выше мы указали целый диапазон значений. Но что если мы хотим знать не только диапазон, но и конкретное значение? Можно конечно напрямую обратиться к переменной, переданной в `match`, однако это не всегда возможно. Например, если в `match` было передано арифметическое выражение, или вызов функции.

В таком случае нам поможет **переменная привзяка** (binding). Это такая переменная, в которую записывается значение которое непосредственно поступило на вход оператора `match`.

Синтаксит:

```
привязка @ шаблон => выражение
```

Теперь перепишем пример выше с использованием привязок:

```rust
fn main() {
    match 22 + 22 {
        x@(0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9) =>
            println!("{x} is less than 10"),
        x@10 .. 100 =>
            println!("{x} is in range [10,99]"),
        x =>
            println!("{x} is equal to or greater than"),
    }
    // Напечатает: 44 is in range [10,99]
}
```

## match как выражение

Оператор `match`, как и оператор `if` возвращает значение. Результат всего оператора `match` — результат отработавшей условной ветки.

Пример оператора `match`, который используется для получения модуля числа (неотрицательной части):

```rust
let a = -5;
let absolute = match a {
  .. 0 => -a, // диапазон от минус бесконечности до 0 невключительно
  _ =>     a,    
};
println!("{absolute}"); // 5
```

## Сравнение со строковыми литералами

В случае если у нас имеется строка `String`, и мы хотим сравнивать её с со строковыми литералами в шаблонах, то нам не удасться передать строку `String` в оператор `match` непосредственно, так как строковые литералы в шаблонах будут иметь тип `&str`.

Для того, чтобы сравнивать `String` со строковыми литаралами `&str` в шаблонах, следует просто получить слайс `&str` на строку из объекта `String`:

```rust
fn main() {
    let name = String::from("Robert Smith");
    let is_anonymous = match name.as_str() {
        "Anonymous" | "John Doe" => true,
        _                        => false,
    };
}
```

## match для слайсов

Для слайсов можно использоваться шаблоны, которые выглядят в точности как шаблоны деструктурирующего присваивания для массивов.

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];

    let s = match v.as_slice() {
        []            => 0,
        [a, b, c, ..] => a + b + c,
        _             => -1,
    };

    println!("{}", s); // 6
}
```

Еще раз напомним, что слайсы нельзя использовать в деструктурирующем присваивании, потому что компилятор не может гарантировать, что для каждой переменной из дестрктурирующего шаблона, в слайсе окажется соответствующий элемент.

Но у `match` такой проблемы нет, так как несовпадение слайса с шаблоном, всего лишь означает, что `match` перейдёт к следующему шаблону, и попытается сопоставить слайс с ним.

## match для структур

Синтаксис шаблонов для структур в паттерн-матчинге очень похож на синтаксис шаблонов для деструктурирующего присваивания, однако позволяет дополнительно задавать значения для полей.

```rust
struct Person { name: String, age: u32 }

fn main () {
    let p = Person { name: String::from("John"), age: 17 };
    match p {
        Person { name, age: 1 .. 18 } => println!("Person {name} is not adult"),
        Person { name, age: 18 }      => println!("Person {name} just turned 18"),
        Person { name, .. }           => println!("Person {name} is adult"),
    }
    // Напечатает: Person John is not adult
}
```

## match if

В шаблонах можно указывать дополнительное условие при помощи ключевого слова `if`.

```rust
struct Person { name: String, age: u32 }

fn main () {
    let p = Person { name: String::from("John"), age: 17 };
    match p {
        Person { name, age } if age < 18 =>
            println!("Person {name} is not adult"),
        Person { name, age } if age == 18 =>
            println!("Person {name} just turned 18"),
        Person { name, .. } =>
            println!("Person {name} is adult"),
    }
    // Напечатает: Person John is not adult
}
```

Условие в блоке `if` может:

* быть составным, т.е. содержать несколько условий, скомбинированных через операторы `||` и `&&`
* обращааться к полям шаблона, биндингам и любым другим доступным, в этом скоупе, именам

## ref

Если в шаблоне нужно "захватить" поле структуры по ссылке, а не по значению, то перед полем нужно указать ключевое слово `ref`.

Пример: при помощи паттерн матчинга, используя шаблон с мутабельной `ref` ссылкой, мы заменим значение поля у объекта, при этом не разрушим его.

```rust
#[derive(Debug)]
struct Person { name: String, age: u32 }

fn main () {
    let mut p = Person { name: String::from("Anonymous"), age: 25 };
    match p {
        Person { ref mut name, .. } if name == "Anonymous" => {
            *name = "John Doe".to_string();
        },
        Person { .. } => (),
    }
    println!("{p:?}"); // Person { name: "John Doe", age: 17 }
}
```

Мы передали переменную `p` в `match` выражение по значению, а не по ссылке. Но поскольку мы обратились к полю `name` по ссылке `ref`, а не по значению, деструктурирование (уничтожение) объекта не произошло. Поэтому переменная `p` осталась действительной после `match`.
