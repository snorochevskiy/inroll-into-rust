# Unsafe

В погоне за гарантированной безопасностью кода, Rust накладывает на код жёсткие ограничения. В безопасном Rust коде:

* На любой объект одновременно можно иметь либо одну мутабельную ссылку, либо сколь угодно много немутабельных ссылок.
* Нельзя разыменовывать указатели
* Нельзя вызывать функции из библиотек, написанных не на Rust

Однако в случае большой необходимости эти ограничения можно выключить для отдельного участка кода, путём оборачивания этого кода в блок `unsafe`.

```rust
unsafe {
    код
}
```

Так же можно пометить целую функцию ключевым словом unsafe.

```rust
unsafe fn функия() {
    ...
}
```

В таком случае, всё тело функции становится `unsafe` блоком. Причём такую `unsafe` функцию можно вызывать только либо из `unsafe` блока, либо из другой `unsafe` функции.

## Указатели

В Rust есть указатели, которые работают практически так же, как и в C.

Для того, чтобы получить указатель на значение, хранимое в переменной, нужно сначала взять сслыку на переменную, а потом при помощи оператора `as`, привести её к типу указателя.

Тип указателя получается путем добавления `*const` (для мутабельного) или `*mut` (для немутабельного указателя), перед типом значения, на которое ссылается указатель.

Например, если переменная имеет тип `i32`, то немутабельный указатель на неё будем иметь тип `*const i32`.

Для того, чтобы разименовать указатель (обратиться к значению по адресу), как и в C, используется оператор `*`.

Рассмотрим простой пример.

```rust
fn main() {
    let a = 5;
    let ptr = (&a) as *const i32; // берём сслыку и преобразуём её в указатель
    unsafe {
        // разыменовываем указатель, чтобы получить значение переменно a
        println!("{}", *ptr); // 5
    }
}
```

Приведение ссылки к указателю является безопасной операцией, и может выполняться вне блока `unsafe`. Но разыменовывание указателя, или преобразование указателя в ссылку требуют `unsafe`.

## Обход ограничения ссылок

Напомним, что в Rust, в каждой точке программы на любой объект, мы может иметь либо одну мутабельную ссылку, либо сколько угодно немутабельных. В подавляющем большистве ситуаций, особенно при написании бекендов, это ограничение никак не мешает. Однако, при написании структур данных или алгоритмов, часто может понадобиться иметь более одной мутабельной ссылки на один и тот же объект.

Например, в двунаправленном списке, нам одновременно нужны две мутабельные ссылки на одни и те же элементы (одна ссылка со стороны головы списка, другая с хвоста).

<img src="../.gitbook/assets/file.excalidraw (11).svg" alt="" class="gitbook-drawing">

Дургой пример — сортировка слиянием (merge sort), которая подразумевает разделение исходной последовательности на участки, каждый из которых сортируется отдельно, а следовательно должен иметь свою мутабельную ссылку.

`unsafe` блок не позволяет напрямую нарушить правило безопасности ссылок, однако `unsafe` позволяет создать дополнительную ссылку через промежуточный указатель:\
мутабельная сслыка → указатель → еще одна мутабельная ссылку.

```rust
fn main() {
    let mut a = 5;
    unsafe {
        let r1: &mut i32 = &mut a; // первая мутабельная ссылка
        let ptr: *mut i32 = r1 as *mut i32; // мутабельный указатель
        let r2: &mut i32 = ptr.as_mut().unwrap(); // указатель во вторую ссылку
        inc(r1);
        inc(r2);
    }
    println!("{a}"); // 7
}

fn inc(a: &mut i32) {
    *a = *a + 1;
}
```

## Работа с указателями

TODO
