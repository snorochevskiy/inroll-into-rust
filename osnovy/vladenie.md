---
description: (ownership)
---

# Владение

Главная отличительная особенность Rust заключается в том, что он, не имея сборщика мусора, предлагает производительность уровня языков с ручным управлением памяти, при этом Rust не требует ручного управления памятью, и гарантирует отсутствием утечек памяти. Такой результат достигается за счёт концепции **владения** данными.

Дело в том, что Rust любой объект не  примитивного типа, должен иметь только одного владельца. **Владелец** - это переменная которой присвоен объект. Поэтому, когда значения одной переменной присваивается другой переменной, владение объектом переходит от первой переменной ко второй, при этом первая переменная становится недействительной.

Рассмотрим пример:

{% code lineNumbers="true" %}
```rust
fn main() {
  let s1 = String::from("some string");
  let s2 = s1; // владение строкой переходит от s1 к s2
  // В этом месте переменная s1 уже не действильна.

  println!("{}", s2); // Теперь можно рабатать только с s2, но не s1
}
```
{% endcode %}

Попытка обратиться к недействильной переменной приведёт к ошибке компиляции:

{% code lineNumbers="true" %}
```rust
fn main() {
  let s1 = String::from("some string");
  let s2 = s1;

  println!("{}", s1);
// 2 |   let s1 = String::from("some string");
//   |       -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
// 3 |   let s2 = s1;
//   |            -- value moved here
// 4 |
// 5 |   println!("{}", s1);
//   |                  ^^ value borrowed here after move
}
```
{% endcode %}

Тот факт, что у любого объекта есть только один владелец, позволяет компилятору однозначно понять в каком месте замять занимаемая объектом должны быть очищена - там, где владелец объекта прекращает своею существование.

Таким образом в тех местах где переменные прекращают своё существование, компилятор вставляет код вызова деструктора для данных, которыми переменные владели.

Такой подход позволяет управлять памятью без сборщика мусора, при этом гарантировать отсутствие утечек.

Механизм компилятора Rust, который отсчеживает время жизни объектов, и гарантирует, что память будет очищена когда нужно, и в коде не будет обращений к уже очищеной памяти, называется борроу-чекером (borrow-checker).

## Владение и скоупы

Как мы знаем, время жизни переменной привязано к скоупу, в котором эта переменная объявлена: когда скоуп завершается, все входящие в него переменные пропадают, арпинадлежащая им память очищается.

Однако переменная, объявленная внутри скоупа, может "отдать" свои данные другой переменной объявленной за пределами этого скоупа.

```rust
fn main() {
  let s1;
  {
    let s2 = String::from("some string");
    s1 = s2;
  }
  println!("{s1}"); // OK
}
```

Это, казалось бы, очевидный код, однако важно понимать как именно работает передачать владения при переходе между скоупами. Это знание нам понадобится в дальнейшем, когда мы будем разибрать [laiftaimy.md](laiftaimy.md "mention")



```rust
fn main() {
  {
    let s1 = String::from("some string");
    let s2 = s1; // "moving" value from s1 to s2, making s1 invalid
    println!("{}", s1); // s1 is invalid
    println!("{}", s2); // OK
  }
  println!("{}", s2); // ERROR, s2 is gone along with it’s value
}
```

## Передача владения

Мы уже знаем, что передача владения объектом происходит при присваивании, но есть и другие сценарии.

Вот полный список операций, при которых происходит передача владения объектом:

* присваивание
* передача объекта в функцию в качестве аргумента
* возврат значения из функции
* захват оъекта замыканием (этот сценарий мы рассмотрим позже)

Давайте рассмотрим сценарий передачи владения при вызове функции:

```rust
fn main() {
    let name = String::from("Stas");

    // Строка из переменной name уходит в функция, делая name недействительной
    let greeting = greet(name);
    // <- Здесь переменная name уже не может быть использовага

    println!("{}", greeting); // Hello Stas!!!
}

fn greet(name: String) -> String {
    format!("Hello {}!!!", name) // result is moved to the caller code
}
```

Теперь когда мы разобрались с тем, что передача переменной в качество аргумента, эту переменную уничтожает, давайте посмотрим на более интересный пример, который выглядит вполне обычно с точки зрения большинства языков программирования, но станет сюрпризом для изучающих Rust .

Допустим мы хотим написать программу, которая выводить на консоль строку (не важно откуда мы её берём), а так же информацию о длине этой строки. Для того, чтобы подсчитать длину строки, мы сделаем отдельную функцию, которая будет просто вызывать `len()` на переданной строке.

<pre class="language-rust" data-line-numbers><code class="lang-rust">fn len_of_string(s: String) -> usize {
    s.len()
}

fn main() {
<strong>    let s = String::from("aaa");
</strong><strong>    let len = len_of_string(s);
</strong>    println!("{}", s); // &#x3C;- переменная s уже недействильна здесь
}
</code></pre>

И вот здесь нас сразу ожидает проблема: на строке (8) мы пытаемся распечатать переменную s, которая уже не действительная, так как она отдала владение своими данными в вызов функции на строке (7).

Как мы можем решить эту проблему? Исключительно абсурдности ради, давайте вспомним, что при помощи кортежей мы можем возвращать из функции несколько значений, а значим мы можем вернуть обратно объект, переденный как аргумент.

```rust
fn len_of_string(s: String) -> (String, usize) {
    let length = s.len();
    (s, length)
}

fn main() {
    let s = String::from("aaa");
    let (s, len) = len_of_string(s);
    println!("Len of {s} is {len}"); // "Len of aaa is 3"
}
```

Выглядит странно, но хорошо демонстрирует как работает перемещение владения объектом при вызове функций.

К счастью, Rust предоставляет куда более удобный механизм для решения этой проблемы - одалживание.

## Одалживание (borrowing)

Вместо того, чтобы передавать в качества аргумента значение переменной, мы можем передавать сслыку на это значение. Таким образом, мы владение объектом остаётся за переменной, и мы лишь даём функции попользоваться объектом.

```rust
fn len_of_string(s: &String) -> usize {
    s.len()
}

fn main() {
    let s = String::from("aaa");
    let len = len_of_string(&s);
    println!("Len of {s} is {len}");
}
```

Такая передача аргумента по ссылке в Rust называется "одалживаем" (borrowing). Это название обусловлено тем, что функция словно берёт объект попользоваться, но возвращает его собственнику после завершения своей работы.

{% hint style="info" %}
Если бы мы писали подобную функцию для реальной программы, мы бы разумеется сделали тип аргумента в `len_of_string` не ссылкой на строку `&String`, а слайсом `&str`, что позволило бы вызывать функцию и для строк `String`, и для строковых литералов.\
Мы написали эту функцию так, исключительно для того чтобы было проще объясненить одалживание.
{% endhint %}

## Безопасность ссылок (referential safety)

Из раздела выше, мы уже знаем, что в Rust можно взять ссылку на объект и передать её в функцию. Но что произойдёт, если эта функция выполняется параллельно в многопоточной среде? А если у нас несколько таких функций, и все они, имея мутабельную ссылку, будут хаотично модифицировать данные? В большинстве языков программирования, такая "гонка данных" является серьезной и сложнодиагностируемой проблемой.

Однако поскольку Rust стремится быть безопасным языком, в нём случществует следующее ограничение относительно взятия ссылок на объект:

> В любом месте кода для любого объекта, может существовать либо только одна мутабельная ссылка, либо любое количество немутабельных ссылок.

То есть мы можем создать сколько угодно немутабельных ссылок и передать их в параллельные потоки, и никакого повреждения данных не произойдёт, так как все потоки только читают данные.

Соответветственно, если хотя бы один поток имеет возможность писать в данные, то без дополнительного механизма синхронизации, нельзя гарантировать, что другой поток сможет читать эти данные корректно, а следовательно компилятор может гарантировать корректность работы с данными только путём запрета создания ссылок для чтения.

Пример ниже не компилируется, так как после взятия мутабельной ссылки, мы пытается взять еще и немутабельную.

{% code lineNumbers="true" %}
```rust
fn main() {
    let mut s = String::from("x");

    let r1 = &mut s; // <-- взятие мутабельной ссылки
    let r2 = & s;    // <-- попытка взять немутабельную ссылку

    println!("{r1}, {r2}");
}
```
{% endcode %}

Компилятор выдаст ошибку:

```
4 |   let r1 = &mut s; // <-- взятие мутабельной ссылки
  |            ------ mutable borrow occurs here
5 |   let r2 = & s;    // <-- попытка взять немутабельную ссылку
  |            ^^^ immutable borrow occurs here
6 |
7 |   println!("{r1}, {r2}");
  |              -- mutable borrow later used here
```

## Moving for primitive types

Все описанные выше правила владения данными не относятся к примитивным типам.

Приметивные типы занымают мало памяти, а так же не владеют какими-то дополнительными ресурсами, поэтому в тех ситуациях где для сложным объектов происходит передача владения, для примитивных типов просто выполняется копирование.

```rust
fn increment(a: i32) -> i32 {
    a + 1
}

fn main() {
    let x = 5;
    let y = increment(x);
    println!("x={}, y={}", x, y);
}
```

## Цикл for и владение

Еще один интересный пример, которые надо рассмотреть в рамках концепции владения, то как владение работает при итерировании фиклом for.

```rust
fn main() {
    let arr = [String::from("1"), String::from("2"), String::from("3")];

    for n in arr {
        println!("{n}");
    }

    println!("{arr:?}");
}
```

Это пример не скомпилируется, так как в цикле for, на каждом витке итерации, следующий элемент массива присваивается переменной \`n\` для последующего использования в теле цикла. Присваивается - значит передаёт владение.

В итоге, мы уничтожили массив просто распечатав его.

Эта проблема решается так же просто, как и проблема с передачей аргумента в функци - путём взятия ссылки.

```rust
fn main() {
    let arr = [String::from("1"), String::from("2"), String::from("3")];

    for n in &arr {
        println!("{n}");
    }

    println!("{arr:?}");
}
```

Теперь когда мы заменили `arr` на `&arr` в заголовке цикла, на каждой итерации перменной `n` присваивается не очередной элемент массива, а ссылка на него. А значит сам массив не уничтожается.

{% hint style="info" %}
После этого примера может показаться, что написание програм на Rust превращается в постоянную борьбу с компилятором. На первых порах так оно может и быть. Однако, после того как Вы привыкнете в концепции владения данными, Вы будете писать правильно на автомате.
{% endhint %}
