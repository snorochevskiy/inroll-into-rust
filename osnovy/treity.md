# Трэйты

{% hint style="info" %}
В русскоязычной литературе по Rust, по-разному переводят слово trait: примесь, типаж. Мы будем использовать англицизм "trait", потому что так говорят даже в русскоязычной среде при обсуждении языка Rust.
{% endhint %}

Трэйты подобны интерфейсам из Java: они декларируют наборы методов, которые должны быть определены для типа, который реализует трэйт.

Синтаксис объявления трэйта:

```rust
trait Имя {
    fn метод_1(&self) -> Тип1;
    ...
    fn метод_N(&self) -> ТипN;
}
```

Синтаксис реализации трэйта для структуры:

```rust
impl Трэйт for Структура {
    fn метод_1(&self) -> Тип1 { ... }
    ...
    fn метод_N(&self) -> ТипN { ... }
}
```

Пример:

{% code lineNumbers="true" %}
```rust
// трэйт, который говорит о том, что тип реализующий его,
// умеет представиться
trait CanIntroduce {
    // метод "представиться"
    fn introduce(&self) -> String;
}

struct Person {
    name: String
}

impl CanIntroduce for Person {
    fn introduce(&self) -> String {
        // Человек представляется называя своё имя
        format!("Hello, I'm {}", self.name)
    }
}

fn main() {
    let person = Person { name: String::from("John") };

    println!("{}", person.introduce ()); // Hello, I'm John
}
```
{% endcode %}



## Полиморфизм

Разумеется трэйты не нужны просто для того, чтобы их реализовывать. Главное применение трэйтов - иметь возможность писать полиморфный код, то есть такой, который взаимодействует с типами не напрямую, а через трэйт, который они реализуют.

В Rust есть два принципиально разных способа передать в функцию аргумент по его трейту, а не конкретному типу:

* Статическая диспетчеризация: указать тип аргумента как `impl Трэйт`
* Динамическая диспетчеризация: указать тип аргумента как `dyn Трэйт`

Если вы программируете на C++, то скорее всего вы уже поняли, что это означает. В противном случае, давайте рассмотрим каждый из этих двух типов.

### Статическая диспетчеризация

Для того, чтобы функция принимала аргументы по трэйту со статической диспетчеризацией, надо объявить аргумент с типом `impl Трэйт`.

Напишем функцию, которая принимает любой тип, реализующий трэйт `CanIntroduce` из примера выше, и печатает "представление" на консоль :

```rust
fn print_introduction(v: &impl CanIntroduce) {
    println!("Value says: {}", v.introduce());
}
```

Разумеется, так как мы принимает аргумент по его трэйту, единственное, что мы можем с ним делать, это то, что объявлено в трэйте. Но это как раз то, что нам нужно.

Для того, чтобы продемонстрировать как эта функция может принимать аргументы разных типов, в дополнению к структуре `Person` давайте создадим еще структуру \`Dog\`, которая так же реализует трэйт `CanIntroduce`.&#x20;

```rust
struct Dog {
    name: String
}

impl CanIntroduce for Dog {
    fn introduce(&self) -> String {
        // Вне зависимости от своего имени, собака может только погавкать
        String::from("Waf-waf")
    }
}
```

Теперь давайте посмотрим как можно вызвать функцию `print_introduction` и для `Person` и для `Dog`.

<pre class="language-rust"><code class="lang-rust"><strong>fn main() {
</strong>    let person = Person { name: String::from("John") };
    let dog    = Dog    { name: String::from("Bark") };

    print_introduction(&#x26;person); // Value says: Hello, I'm John
    print_introduction(&#x26;dog);    // Value says: Waf-waf
}
</code></pre>

А теперь давайте поговорим о том, как это работает, и почему диспетчеризация называется статической.

Дело в том, что когда компилятор встречает использование функции, имеющий `impl Трэйт` аргумент, он генерирует вариант этой функции для контретного типа, с которым функция вызывается. Генерация функции с конкретным типов вместо трэйта, называется **мономорфизацией**.

То есть, найдя вызов функции `print_introduction` для `Person`, а потом для `Dog`, компилятор сгенерирует, что-то вроде (рузмеется, имена будут не такими):

```rust
fn print_introduction_$Person(v: &Person) {
    println!("Value says: {}", v.introduce());
}
fn print_introduction_$Dog(v: &Dog) {
    println!("Value says: {}", v.introduce());
}
```

А далее, компилятор изменит вызовы абстрактной print\_introduction, на вызовы конкретных вариантов:

<pre class="language-rust"><code class="lang-rust"><strong>fn main() {
</strong>    let person = Person { name: String::from("John") };
    let dog    = Dog    { name: String::from("Bark") };

    print_introduction_$Person(&#x26;person);
    print_introduction_$Dog(&#x26;dog);
}
</code></pre>

Таким образом, каждый из сгенерированных вариантов функции `print_introduction` будет знать с каким именно конкретным типом он работает, а значит ему будет известне адрес нужного метода `introduce` именно для того типа, с которым работает этот вариант `print_introduction`.

<img src="../.gitbook/assets/file.excalidraw (2).svg" alt="" class="gitbook-drawing">

Все адреса методов статичны, поэтому диспетчеризация и называется статической.\


### Динамическая диспетчеризация

В противовес статической диспетчеризации, существует и динамическая. На первый взгляд, различие в коде между статической диспетчеризацией и днамической - минимально: нужно просто `impl Трэйт` заменить на `dyn Трэйт`.

Вот как будет выглядеть вариант \`print\_introduction\` с динамической диспетчеризацией:

```rust
fn print_introduction(v: &dyn CanIntroduce) {
    println!("Value says: {}", v.introduce());
}
```

При этом вызовы этой функции для типов Person и Dog вообще не изменились:

```rust
fn main() {
    let person = Person { name: String::from("John") };
    let dog    = Dog    { name: String::from("Bark") };

    print_introduction(&person); // Value says: Hello, I'm John
    print_introduction(&dog);    // Value says: Waf-waf
}
```

На первый взгляд, разницы нет, но внутри всё работает совершенно по-другому. Если при статической диспетчеризации, компилятор генерирует столько вариантов функции, сколько разных типов в неё передаётся, то при динамической диспетчеризации, функция всего одна.

Каким же тогда образом `print_introduction` понимает для какой реализацией `CanIntroduce` она вызвана, и какой из вариантов метода `introduce` следует вызвать? Дело в том, что аргумент `&dyn CanIntroduce` - это не просто ссылка на объект, переданный в качестве аргумента, это две сслыки: первая на сам объекта, а вторая на **vtable** (таблица виртуальных вызовов) для конкретного типа аргумента.

Когда компилятор замечает, что объект некого типа передаётся как аргумент с динамической диспетчеризацией, то он генерирует специальную таблица, в которой храняться имена методов этого типа, и адреса этих методов (именно для этого типа) в сегмента кода.

В самой же функции, которая принимает аргумент с динамической диспетчеризацией, вставляется код, который ищёт в таблица виртуальных методов вдрес с нужной функцией, а потом вызывается её.

Чтобы всё это работало, когда объект передаётся в функцию как `dyn Трэйт`, комплятор передаёт в эту функцию не только адрес объекта, но и адрес соответствующей vtable.

<img src="../.gitbook/assets/file.excalidraw (3).svg" alt="" class="gitbook-drawing">

Эта `dyn Трэйт`, который состоит из пары (ссылки на значение, ссылка на vtable), называется **трэйт объектом** (**trait object**).

### impl vs dyn

Подвдём итог. Есть два способа обращения к типу через реализуемый им трэйт:

* `impl Трэйт` – заменяется на конкретный тип при компиляции
* `dyn Трэйт` – заменяется на трэйт объект, который проксиреут вызовы методов на реальный тип при помощи динамической диспетчеризации

{% hint style="info" %}
Если вы не знакомы с C++, детали динамической диспетчеризации, скорее всего, будут плохо понятны. Не пытайтесь понять всё сразу досконально за раз, просто вернитесь к этой теме потом, после того как освоитесь с Rust на базовом уровне, и будете готовы к более глубокому изучению.
{% endhint %}

На данном этапе мы еще не имеем достаточно знаний, чтобы рассмотреть все аспекты использования трэйт объектов, но пока что можем сказать следующее:

* Вызовы методов по средствам статической типизации работают гораздо быстрее, потому что вызов осуществляется напрямую по адресу метода, а в то время как при динамической диспетчерезации сначала нужно найти адрес метода в vtable
* Так как при статической диспетчеризаии `impl Трэйт` просто подменяется на конкретный тип, то такой агрумент можно передавать как по ссылке `&impl Трэйт`, так и по значению - просто `impl Трэйт`.
* В отличии от `impl Трэйт`, `dyn Трэйт` нельзя передать по значению, так как для вызова функции необходимо знать точный размер аргумента, а этот аргумент неизвестно какого типа. Поэтому трэйт объект передается либо по ссылке - `&dyn Трэйт`, или через указатель.

## Определение трэйта для "чужих" типов

Поскольку имплементация трэйт для структуры происходит за пределами тела самой структуры (в отличии от интерфейсов и абстрактных классов в ООП языках), вожно имплементировать трэйт для структуры, которые нам не принадлежат (из других библиотек).

```rust
trait CanIntroduce {
    fn introduce(&self) -> String;
}

impl CanIntroduce for &str {
    fn introduce(&self) -> String {
        String::from("I am string slice")
    }
}

impl CanIntroduce for i32 {
    fn introduce(&self) -> String {
        String::from("I am integer")
    }
}

fn print_introduction(v: impl CanIntroduce) {
    println!("Value says: {}", v.introduce());
}

fn main() {
    print_introduction("a"); // Value says: I am string slice
    print_introduction(5);   // Value says: I am integer
}
```

В Rust существует правило "Orphan rule" (правило сирот), которое гласит: трэйт можно реализовать для типа, только в том случае, если либо трэйт, либо тип (либо оба) принадлежит библмотеке в котором осуществляется реализация.

То есть, не смотря на то, что тип `i32` принадлежит стандартной библиотеке, мы смогли реализовать для него трэйт `CanIntroduce` только потому что, трэйт `CanIntroduce` объявляет нами в нашем крэйте.

В главе [#newtype-pattern](treity.md#newtype-pattern "mention") мы подробнее рассмотрим Orphan rule, и способ обхода этого ограничения.

## Возврат трэйта из функции

Rust не только передавать аргументы через трэйт, но и возвращать трэйт из функции.

Принцип такой же, как и с приёмом аргументов:

* если возвращаемый тип `impl Trait`, то компилятор проведёт замену на конкретный тип
* если возвращаемый тип `dyn Trait`, то компилятор создаст трэйт объект

Например:

```rust
fn make_person() -> impl CanIntroduce {
    Person { name: String::from("John") }
}
```

Однако есть нюанс: поскольку компилятор просто заменяет `impl Трэйт` просто заменяется на конкретный тип, из такой функции нельзя возвращаться два разных типа.

Рассмотрим пример:

```rust
fn make_someone(is_person: bool) -> impl CanIntroduce {
    if is_person {
        Person { name: String::from("John") }
    } else {
        Dog { name: String::from("Bark") }
    }
}
```

Такая функция невозможна, так как `impl CanIntroduce` должен быть заменён на конкртеный тип, но если он будет заменён на `Person`, то возврат объекта `Dog` будет не корректен, и наоборот.&#x20;

Возврат `dyn Трэйт` в этой ситуации работает прекрасно:

```rust
fn make_someone(is_person: bool) -> Box<dyn CanIntroduce> {
    if is_person {
        Box::new(Person { name: String::from("John") })
    } else {
        Box::new(Dog { name: String::from("Bark") })
    }
}

fn main() {
    let person = make_someone(true);
    let dog    = make_someone(false);

    print_introduction(person.as_ref());
    print_introduction(dog.as_ref());
}
```

В этом примере присутствует тип, с которым мы пока еще не знакомы - `Box`. Это фактически просто безопасная обёртка как unsafe указателем. Конструктор `Box::new(значение)`, перености значение со стека в кучу, и возвращает объект `Box`, внутри которого содержится указатель с адресом объекта в куче. Подробнее мы разберём Box в главе [umnye-ukazateli.md](umnye-ukazateli.md "mention").

Главная причина по которой мы используем `Box<dyn Трэйт>`, а не `&dyn Трэйт` заключается в том, что мы не можем вернуть ссылку на объект, который создан на стеке при выполнении функции. Ведь при выходе из функции, её стэк-фрэйм будет очищен вместо со всеми находящимися в нём объектами, и ссылка на любой из этих объектов станет недействительной. Именно поэтому мы переносим объект в кучу, и возвращаем из функции указатель (Box) на этот объект в куче.

## Дефолтные имплементации методов

Методы в трэйте могут иметь реализации по умолчанию. Разумеется, их тоже можно переобпределить при необходимости.

```rust
trait CanIntroduce {
    fn say_name(&self) -> String;
    fn introduce(&self) -> String { // реализация по умолчанию
        format!("Hello, I am {}", self.say_name())
    }
}

struct Person {
    name: String
}

impl CanIntroduce for Person {
    fn say_name(&self) -> String {
        self.name.clone()
    }
}

fn main() {
    let person = Person { name: String::from("John") };
    // Вызываем дефолтную реализацию метода introduce
    println!("{}", person.introduce()); // Hello, I am John
}
```

Методы с реализацией по умолчанию переопредяются так же как и обычные методы трэйтов:

```rust
impl CanIntroduce for Person {
    fn say_name(&self) -> String {
        self.name.clone()
    }
    fn introduce(&self) -> String { // переопределяем
        format!("Hi, I'am {}", self.say_name())
    }
}
```

## Наследование трэйта

В Rust трэйт может "наследовать" другой трэйт.

```rust
trait A : B { ... } // Трэйт A "наследует" трэйт B
```

На практике это означает, что если мы хотим реализовать для нашего типа трэйт A, то мы обязательно должны реализовать и трэйт B для него.

Например:

```rust
trait HasName {
    fn say_name(&self) -> String;
}

// Все кто реализуют CanIntroduce, должны реализовать и HasName
trait CanIntroduce : HasName {
    fn introduce(&self) -> String;
}

struct Person {
    name: String
}

impl CanIntroduce for Person {
    fn introduce(&self) -> String {
        format!("Hello, I am {}", self.say_name())
    }
}

// Компилятор обяжет сделать реализацию для HasName
// после того как найдёт реализацию для CanIntroduce
impl HasName for Person {
    fn say_name(&self) -> String {
        self.name.clone()
    }
}

fn main() {
    let person = Person { name: String::from("John") };
    println!("{}", person.introduce()); // Hello, I am John
}
```

## Ограничение несколькими трэйтами

Когда мы указываем трэйт в качестве аргумента функции, мы по сути, накладывает ограничение на типы, которые можно передавать в эту функцию.

Например, объявляя аргумент так:

```rust
fn print_introduction(v: impl CanIntroduce) { ... }
```

мы накладываем ограничение, что функция может быть вызвана только с аргументом, чей тип реализует трэйт `CanIntroduce`. Но что, если нам нужно, чтобы агрумент реализовывал два трэйта? В таком случае, надо просто перечислить необходимые трэйты через знак `+`.

```rust
trait CanIntroduce { ... }
trait HasJob { ... }

fn print_worker_introduction(v: &(impl CanIntroduce + HasJob)) {
```

Важно сказать, что такой синтаксис для указания ограничения в виде нескольких трэйтов практически никогда не используется. Вместо него используется другой синтаксис, который мы рассмотрим в главе [generiki.md](generiki.md "mention").

### Self

Не редко, в объявлении трэйта необходимо сослаться на конкретный тип, для которого будет реализован трэйт. Для этого используется ключевое слово `Self` (с заглавной буквы).

Например, создадим трэйт, который декларирует, что у типа должена быть функция-конструктор по умолчанию:

```rust
trait HasDefaultConstructor {
    fn make_default() -> Self;
}
```

Когда мы пишем этот трэйт, мы еще не знаем, какой тип будет возвращать функция \`make\_default\` (потому что это будет зависеть от типа для которого мы реализует этот трэйт), поэтому мы не можем указать конкретное имя типа. Именно здесь на помощь приходит `Self`.

Давайте теперь реализуем этот трэйт для уже знакомого нам по главе типа `Person`:

```rust
struct Person {
    name: String
}

impl HasDefaultConstructor for Person {
    fn make_default() -> Self {
        Person { name: "Anonymous".to_string() }
    }
}

fn main() {
    let p = Person::make_default();
    println!("Default name: {}", p.name);
}
```

В реализации методов трэйта можно оставить `Self` - `fn make_default() -> Self`, но и можно заменить на название конкретного типа `fn make_default() -> Person` - эффект будет одинаковым.
