# Лайфтаймы

Мы уже знаем, что в Rust каждый объект имеет только одного владельца, но этот владелец может одалживать объект по ссылке в другие участки кода. При этом компилятор будет проверять, что время жизни скоупа, одолжившего объект, не больше чем время жизни владельца этого объекта.

Теперь давайте взглянем на такой код:

```rust
// Функция принимает две ссылки на строки, и возвращает ту ссылку,
//  которая указывает более длинную строку.
fn take_longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() { x } else { y }
}

fn main() {
    let l = take_longest("aaa", "bbbb");
}
```

Попытка скомпилировать этот код провалится с ошибкой:

> error\[E0106]: missing lifetime specifier\
> help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from \`x\` or \`y\`\
> help: consider introducing a named lifetime parameter

Эта ошибка говорит, что компилятор не уверен о том, как соотносятся между время жизни владельца первой строки, время жизни владельца второй строки, и время жизни переменной, которой будет присвоен результат функции.

Чтобы стало понятнее, давайте взглянем на такой вариант использования функции `take_longest`:

```rust
let s1 = String::from("aaa");
let longest;
{
    let s2 = String::from("bbbb");
    longest = take_longest(s1.as_str(), s2.as_str());
}
```

Как мы видим, при таком сценарии, ссылка на строку, принадлежащую переменной s2, будет записана в переменную `longest`. Проблема в том, что переменная `longest` принадлежит скоупу, который "живёт" дольше, чем скоуп в который входит `s2`. А как мы сказали выше, компилятор проверяет, что ссылка на объект не "живёт" дольше, чем переменная, которой этот объект принадлежит.

Для решения этой проблемы, необходимо явно указать как должны соотноситься между собой время жизни владельцев объектов, на которые ссылаются агрументы функции, и время жизни переменной, куда рузьтат функции будет записан.

Указываются такие отношения времени жизни при помощи лайфтаймов (lifetime).

```rust
fn take_longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

Здесь в заголовке функции `take_longest<'a>` мы обяъвляем некий относительный лайфтайм `'a`. Далее, в каждоый ссылке, после знака `&` мы указываем в какому лайфтайму принадлежит ссылка.

Запись лайфтаймов в фунции `take_longest` можно прочитать так:

> Cуществует некий лайтайм `'a` произвольной длины, который не короче времени жизни функции `take_longest`. Владельцев объектов, на которые ссылаются `x` и `y` должны принадлежать к одному скоупу. А время жизни переменной принимающей результат функции, не должно быть больше этого скоупа.

После того, как мы задали лайфтаймы, такая попытка использовании функции `take_longest` приведёт к ошибке компиляции.

```rust
fn main() {
  let s1 = String::from("aaa");
  let longest;
  {
    let s2 = String::from("bbbb");
    longest = take_longest(s1.as_str(), s2.as_str()); // does not live long enough
  }
  println!("The longest string is {}", result);
}
```

## Лайфтаймы для структур



## 'static лайфтайм



## Сложности работы с лайфтаймами

Как правило, для тех, кто начинает изучать Rust, именно лайфтаймы становятся наиболее сложным в использовании инструментом. Поэтому, если на первых порах, вы испытываете сложности с написание лайфтаймов, то рекомендуется не заморачиваться со сложными связями между ссылками, а просто использовать `.clone()` для получения копии объекта.

Позднее, когда вы лучше  освоителесь с языком, вы можно будет углубиться в лайфтаймы отдельно.
