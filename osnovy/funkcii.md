# Функции

Как и в других языках программирования, в Rust функции - это механизм, позволяющий разбить программу, на отдельные гранулированные подпрограммы.

Синтаксис объявления функции:

```rust
fn func_name(arg1: Тип1, arg2: Тип2) -> тип_возвращаемого_значения {
    тело функции
}
```

Пример:

```rust
fn sum(a: i32, b: i32) -> i32 {
    a + b
}

fn safe_divide(a: f32, b: f32) -> f32 {
    if b != 0 {
        a / b
    } else {
        0
    }
}

fn main() {
    let a = sum(1, 2);
    println!("{a}");
    
    let b = safe_divide(12, 4);
    println!("{b}");
}
```

При объявлении аргументов функции, можно вставлять запятую после последнего аргумента, и поведение будет таким же, как и без ней.

```rust
fn sum(a: i32, b: i32,) -> i32 { .. }
```

## return

Как мы видим, последнее вычисленное значение автоматически является результатом функции.

Если нужно "досрочно" выйти из функции, то нужно явно использовать оператор return:

```rust
fn safe_divide(a: f32, b: f32) -> f32 {
    if b == 0 {
        return 0;
    }
    a / b
}
```

## Функции внутри функций

Rust позволяет объявлять функцию внутри другой функции.

Внутренние функции используют, когда часть функциональности явно хорошо гранулирована, и вынесение этой функциональности в отдельную функцию может повысить выразительность. При этом эта функциональность не нужна нигде за пределами "родительской" функции.

```rust
// Возвращает i-й элемент последовательности Фибоначчи.
// Индексация элементов последовательности - с нуля.
fn fibonacci_nth_element(index: usize) -> u32 {
    if index == 0 {
        return 0;
    }
    if index == 1 {
        return 1;
    }
    // Высчитывет i-й элемент последовательности Фибоначчи
    // * x0            - i-й элемент последовательности
    // * x1            - (i+1)-й элемент последовательности
    // * next_index    - индекс следующего (i+2) элемента
    // * desired_index - индекс искомого элемента
    fn next_fibonacci(x0: u32, x1: u32, next_index: usize, desired_index: usize) -> u32 {
        let x2 = x0 + x1;
        if next_index == desired_index {
            x2
        } else {
            next_fibonacci(x1, x2, next_index + 1, desired_index)
        }
    }

    next_fibonacci(0, 1, 2, index)
}

fn main() {
    println!("{}", fibonacci_nth_element(0)); // 0
    println!("{}", fibonacci_nth_element(1)); // 1
    println!("{}", fibonacci_nth_element(2)); // 1
    println!("{}", fibonacci_nth_element(3)); // 2
    println!("{}", fibonacci_nth_element(4)); // 3
}
```

Так же внутренние функции удобны, когда часть часть логики функции может быть переиспользована в ней же самой.

## return и never type

{% hint style="info" %}
Приведённая ниже информация не является необходимой для программировании на Rust, а скорее просто даёт лучшее понимание системы типов.
{% endhint %}

В главе [primitivnye-tipy-dannykh.md](primitivnye-tipy-dannykh.md "mention") мы уже упоминали never type `!`, который используется для выражений, которые не возвращают управление в вызывающий код.

Never type не представляет каких-то реальных данных, а просто играет роль заглушки, чтобы склеить воедино систему типов Rust.

Так вот, тип оператора return - как раз `!`, а всё потому что он не возвращает управление в функцию, в которой он находится, а выходит из функции в то место, откуда она была вызвана.

```rust
fn gen_num() -> i32 {
    // Переменная v имеет тип !
    let v = return 5;
}
  
fn main() {
    let a = gen_num();
}
```

