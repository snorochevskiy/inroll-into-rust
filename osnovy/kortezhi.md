# Кортежи

Как мы знаем, массив в Rust — это последовательность заранее известного размера, содержащая элементы одинакового типа. Поэтому массивы хорошо подходят для хранения таких сущностей, как, например, координаты в пространстве:  `[x, y, z]` — все три составляющие координаты имеют одинаковый тип. Но что делать, если для хранения какой-то сущности требуется последовательность элементов разного типа? Например, мы разрабатывает картотеку для отдела кадров, и по каждому сотруднику нам необходимо хранить его полное имя, дату рождения и пометку является ли сотрудник действующим — всё это данные разных типо: `String`, `u32` и `bool`.\
Решить нашу задачу могут помочь кортежи.

**Кортеж** — это последовательность, заранее известного размера, которая может содержать элементы разных типов.

{% hint style="info" %}
Программисты на Java могут провести аналогию с классами Pair\<T1,T2> и Triplet\<T1,T2,T3> из библиотеки Apache Commons
{% endhint %}

Синтаксис объявления кортежа выгляди так:

```
(значение_, значение_2, …, значение_N)
```

Пример: кортеж для хранения информации о сотруднике, о которой мы говорили выше:

```rust
let employee: (&str, i32, bool) = ("John Doe", 1980, true);
```

Доступ к элементам кортежа осуществляется при помощи `.` после которой следуют индекс элемента (индексация с нуля).

```rust
println!(
  "Name: {}, birth year: {}, active: {}",
  employee.0, employee.1, employee.2
);
```

Так же для кортежей есть удобный синтаксис, который позволяет за раз "разложить" весь кортеж на элементы, и присвоить эти элементы переменным.

```rust
let (name, birth_year, is_active) = employee;
```

{% hint style="info" %}
Такая операция "разложения" на составляющие называется деструктурирующим присваиванием. О ней мы отдельно поговорим в главе [destrukturiruyushee-prisvaivanie.md](destrukturiruyushee-prisvaivanie.md "mention")
{% endhint %}

## Возврат кортежа из функции

Одно из удобных применений кортежа — возврат нескольких значений из функции.

Например, нам нужна функция, которая принимает в качестве аргумента последовательность чисел, и разделяет её на две части: первая содержит все нечётные числа, вторая — все чётные.

{% code lineNumbers="true" %}
```rust
fn split_to_odd_and_even(numbers: &[i32]) -> (Vec<i32>, Vec<i32>) {
  let mut odds = Vec::new();  // для нечётных
  let mut evens = Vec::new(); // для чётных
  for n in numbers {
    if n % 2 != 0 {
      odds.push(*n);
    } else {
      evens.push(*n);
    }
  }
  (odds, evens)
}

fn main() {
  let numbers = vec![1,2,3,4,5,6,7,8,9];
  let (odds, evens) = split_to_odd_and_even(&numbers); // получаем слайс на вектор
  println!("Odd numbers:  {odds:?}");
  println!("Even numbers: {evens:?}");
}
```
{% endcode %}

Как мы видим, здесь в теле функции `split_to_odd_and_even` мы создали два вектора, и оба вернули из функции путём "заворачивания" в кортеж.

Так же заметим, что функция `split_to_odd_and_even` в качестве аргумента принимает слайс, поэтому в строке (11) при помощи оператора `&` мы создаём слайс, указывающий на элементы вектора.

Передача последовательностей в функии по средствам слайса — одна из распостранённых практик в Rust. Это позволяет вызывать функцию как для вектора, так и для массива.

Например, так бы выглядел вариант с массивом:

```rust
fn main() {
  let numbers = [1,2,3,4,5,6,7,8,9];
  let (odds, evens) = split_to_odd_and_even(&numbers); // получаем слайс на массив
  println!("Odd numbers: {odds:?}");
  println!("Even numbers: {evens:?}");
}
```
