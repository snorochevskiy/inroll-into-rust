# Вектор

Как мы уже знаем, размер массива должен быть известен во время компиляции, что делает его бесполезным в большинстве ситуаций, так как в большинстве реальных ситуаций, количество элементов становится известным только во время выполнения программы.

Тип `Vec` - вектор, так же представляет из себя непрерывную последовательность элементов, которая может динамически расширятся и сужаться.

{% hint style="info" %}
`Vec<T>` является обобщённой (generic) структурой. И генерики, и структуры мы изучим только несколько глав спустя, однако, вектор является настолько вездесущей стуруктурой данных, что изучать даже базовые конструкции Rust без него будет очень сложно. Поэтому, на данном этапе мы только разберёмся как с ним работать, и как он располагается в памяти.\
Если же Вы знакомы с Си++, то Вы уже, скорее всего, провели аналогию с шаблонным класом `std::vector`, и оказались полностью правы.\
Если Вы знакомы с Java, то считайте вектор близким родственником класс `ArrayList<T>`.
{% endhint %}

Для начала рассмотрим пример использования вектора:

{% code lineNumbers="true" %}
```rust
fn main() {
  let mut my_vec: Vec<i32> = Vec::new();

  my_vec.push(1);
  my_vec.push(2);
  my_vec.push(3);

  let third: i32 = my_vec[2];
  println!("3-rd element: {}", third);
}
```
{% endcode %}

Здесь мы в строке (2) создаём пустой вектор, который будет хранить элементы числового типа `i32`.\
Далее, в строках (3,4,5) мы помещаем в вектор числа 1, 2 и 3.\
Под конец, в строке (8) мы объявляем переменную `trird`  и присваиваем ей третий элемент вектора (индексация элементов в векторе, как и в массиве, начинается с нуля).

Как видно, с точки зрения использования, вектор довольно просто. Можно думать о нём, просто, как о динамически расширяемом массиве.

Теперь поговорим о том, как вектор хранится в памяти. Когда мы создаём переменную вектора, то на стеке располагается только его "служебная ифнормация", а сами данные хранятся в куче - в буфере, который вектор для себя аллоцирует в момент своего создания. На стеке хранятся такие 3 поля:

* указатель на начало буфера в куче - в этом буфере хранятся сами элементы вектора
* счётчик количества элементов записанных в буфер в куче
* размер буфера в куче

Лэйаут (layout) в памяти, для вектор из примера выше, выглядит так:

<img src="../.gitbook/assets/file.excalidraw (7).svg" alt="Vec<i32> memory layout" class="gitbook-drawing">

Размер по умолчанию для буфера в куче, который вектор изначально создаёт не стандартизирован, но да данной диаграмме мы предположили, что он равен 5.

Если желаемый размер буфера в хипе известен на момент создания вектора, то его можно задать явно заменив `Vec::new()`  на `Vec::with_capacity(размер)`. Это приведёт к тому, что вектор аллоцирует первичный буфер в куче ровно такого размера, чтобы иметь возможность вмести ровно заданное количество элементов.

### Макрос vec!

Создавать вектор путем сначала объявления пустого вектора, а потом добавлением в него элементов по одному, выглядит многословным. Поэтому, учитывая, что вектор является найболее часто используемой структурой данных, в стандартную библиотеку Rust включили специальный макрос `vec![]`, который берёт на себя бремя поэлементного добавления элементов в вектор.

При помощи этого макроса, мы можем переписать пример выше таким образом:

```rust
fn main() {
  let mut my_vec = vec![1,2,3];

  let third: i32 = my_vec[2];
  println!("3-rd element: {}", third);
}
```

Как работает этот макрос станет понятно только после прочтения главы о макросах, однако принцип его использования должен быть понятен уже сейчас: макрос просто раскрывается компилятором в код, который сначала создаёт пустой вектор, а далее заталкивает в него элементы по одному, так же, как мы делали это без макроса.
