# Декларативные макросы

В Rust есть три вида макросов:

* Декларативные мароксы. Эти макросы обрабатываются после того как исходный текст программы преобразован в AST (абстратктное синтаксическое дерево). Они манипулируют AST узлами, что делает их простыми в написании, при этом довольно безопасными.\
  По сути, декларативные макросы - это функции, которые выполняются на этапе компиляции, и манипулируют не данными, а узлами AST.
* Процедурные макросы. Эти макросы принимают на вход последовательность токенов, и выдают на вход тоже последовательность токенов. То есть они отрабатывают до лексического разбора текста программы, поэтому позволяют буквально создать другой язык внутри программы на Rust. Мы не будет изучать процедурные макросы в рамках этой главы.

## Наш первый декларативный макрос

Декларативные макросы объявляются при помощи аннотации `#[macro_export]` после которого следует описание макроса на специальном Schema-подобном синтаксисе.

```
#[macro_export]
macro_rules! имя_макроса {
  шаблон_1 => { подстановка 1 };
  шаблон_2 => { подстановка 2 };
  ...
  шаблон_N => { подстановка N }
}
```

Для начала давайте посмотрим на простейший макрос, который суммирует два числа, а потом разберёмся в его описании:

```rust
#[macro_export]
macro_rules! sum_nums { // объявляем макрос с именем sum_nums
    ( $x:expr, $y:expr ) => { $x + $y }
}

fn main() {
    let res = sum_nums!(1, 2); // вызываем макрос
    println!("Sum is: {}", res);
}
```

При компиляции программы, вызов макроса будет раскрыт в следующее:

```rust
fn main() {
    let res = 1 + 2;
    println!("Sum is: {}", res);
}
```

Как видно, компилятор просто заменил вызов макроса на сгенерированный им Rust код, а дальше продолжил компиляцию.

Теперь когда у нас появилось примерное представления того как макросы выглядят, давайте подробно разберём макрос их нашего примера.

```rust
#[macro_export]
macro_rules! sum_nums {
    ( $x:expr, $y:expr ) => { $x + $y }
}
```

Здесь на строке (3) мы видим шаблон для того, что мы ожидаем в качестве аргумента в нашем макросе. Синтаксис аргументов иммет вид: `$имя_аргумента : тип_аргумента`.

&#x20;`( $x:expr, $y:expr )` означает, что мы ожидаем два аргумента, каждый из которых должен быть корректным _выражением_ (тип `expr` означает выражение) на языке Rust.

Именно контроль типов аргументов делает декларативные макросы такими удобными и безопасными. Например, мы можем вызвать этот макрос для любых корректных выражений:

```rust
sum_nums!(1 + 1, 2 + 2); // 1 + 1 + 2 + 2

sum_nums!({ 1 + 1 }, { 2 + 2 }) // { 1 + 1 } + { 2 + 2 }

sum_nums!(if 5 > 4 { 1 } else { -1 }, 9); // if 5 > 4 { 1 } else { -1 } + 9
```



## Типы аргументов макросов

Кроме выражений, макросы могут различать целый ряд видов кода на Rust. Ниже полный список допустимых типов аргументов для макросов, со многими из которых мы пока что не знакомы. Не стоит заострять своё внимание на них, мы приводим полный перечень типов исключительно для того, чтобы показать насколько "умны" макросы в Rust.

<table><thead><tr><th width="119.66668701171875">Фрагмент</th><th width="450.0001220703125">Сопоставляется с</th><th>после может быть</th></tr></thead><tbody><tr><td><code>expr</code></td><td>Выражение на Rust: <code>2 + 2</code>, <code>"aaa"</code>, <code>x.len()</code></td><td><code>=></code> <code>,</code> <code>;</code></td></tr><tr><td><code>stmt</code></td><td>Инструкция (то что до точки с запятой)</td><td><code>=></code> <code>,</code> <code>;</code></td></tr><tr><td><code>ty</code></td><td>Тип данных: <code>String</code>, <code>Vec&#x3C;u8></code>, <code>(&#x26;str, bool)</code></td><td><code>=></code> <code>,</code> <code>=</code> `</td></tr><tr><td><code>path</code></td><td>Путь: <code>crate::module</code>, <code>::std::sync::mpsc</code></td><td><code>=></code> <code>,</code> <code>=</code> `</td></tr><tr><td><code>pat</code></td><td>Деструктурирующий шаблон: <code>_</code>, <code>Some(ref x)</code></td><td><code>=></code> <code>,</code> <code>=</code> `</td></tr><tr><td><code>item</code></td><td>Артикул: <code>struct Point {x: f64, y: f64}</code>, <code>mod ferns;</code></td><td>что угодно</td></tr><tr><td><code>block</code></td><td>Блок кода / скоуп: <code>{ s+= "ok"; true }</code></td><td>что угодно</td></tr><tr><td><code>meta</code></td><td>Тело атрибута: <code>inline</code>, <code>derive(Copy,Clone)</code>, <code>doc="3d models."</code></td><td>что угодно</td></tr><tr><td><code>ident</code></td><td>Идентификатор: <code>std</code>, <code>Json</code>, <code>my_var</code></td><td>что угодно</td></tr><tr><td><code>tt</code></td><td>Дерево лексем: <code>;</code> , <code>>=</code>, <code>{}</code>, <code>[0 1 (+ 0 1)]</code></td><td>что угодно</td></tr><tr><td><code>literal</code></td><td>Литерал: <code>5</code>, <code>5u32</code>, <code>1.0</code>, <code>"Hello"</code></td><td></td></tr><tr><td><code>vim</code></td><td>Visibility qualifier: <code>pub</code>, <code>pub (crate)</code></td><td></td></tr></tbody></table>

Как видите, благодаря системе типов для аргументов, макросы в Rust куда бозопаснее, чем в Си, ведь при неправильном использовании макроса, мы получим осмысленную ошибку компиляции именно для макроса, а не для некорректно-сгенерированного макросом кода. \


## Переменное число аргументов

В Rust отсутствуют функции с переменным числом аргументов, однако это ограничение компенсируется макросами.

Давайте рассмотрим макрос который принимает произвольное число чисел, и конструирует их сумму:

```rust
#[macro_export]
macro_rules! sum_nums {
    () => { 0 };
    (  $first:literal $(, $rest:literal )* ) => {
        $first $( + $rest )*
    };
}

fn main() {
    let res = sum_nums!(1, 2, 3, 4, 5);
    println!("Sum is: {}", res); // Sum is: 15
}
```

В этом макросе у нас два шаблона.

С первым шаблоном `() => { 0 }` всё просто: он обрабатывает случай, если в вызов макроса не было передано ниодного значения. В этом случае мы просто возвращаем `0` (без каких либо арифместических обоснований, мы просто так решили в данном сценарии).

Второй шаблон ожидает как минимум один аргумент, который будет привязан к `$first`. Далее может следовать произвольное количество чисел, предварённых запятой, и вся эта последовательность будет привязан к `$( $rest )*`, причём сама запятая будет отброшена, так как она не привязывается к какому-то имени аргумента.

Результат подставновки шиблона мы формируем, как, сначала, литерал привязанный к `$first`, а затем все элементы последовальености привязанные к `${$rest}*`, причём перед каждым элементом мы добавляем знак `+`.

Таким образом вызов `sum_nums!(1, 2, 3, 4, 5)` превращается в `1 + 2 + 3 + 4 + 5`.

***

Этот макрос можно переписать более простым способом:

```rust
#[macro_export]
macro_rules! sum_nums {
    ( $( $rest:expr ),* ) => { 0 $( + $rest )* }
}
```

Здесь мы просто воспользователись тем, что сложения любого числа с нулём, даёт это же число. Поэтому мы привязываем все аргументы макроса к \`$( $rest )\*\`, а в теле подстановки шаблона мы складываем \`0\` со всеми аргументами макроса.

```rust
sum_nums!(1,);      // 0 + 1
sum_nums!(1, 2, 3); // 0 + 1 + 2 + 3
sum_nums!();        // 0
```

## Скобки

Как вы могли заметить, мы вызывем наш макрос используя круглые скобки: `sum_nums(1,2)`. При этом макрос `vec!` мы вызываем с импользованием квадратных скобок. В чём же разница?

На самом деле и нам макрос, и `vec` можно вызывать с любыми скобками:

```rust
sum_nums!(1, 2);
sum_nums![1, 2];
sum_nums!{1, 2};
vec!(1, 2, 3);
vec![1, 2, 3];
vec!{1, 2, 3};
```

Какой вариант кажется выразительнее, тот и можно использовать.

Единственная разница заключается в необходимости ставить `;` после вызова макроса, когда мокрас используется для генерации функций или структур: после вызова с фигурными скобками `;` ставить не надо:

<pre class="language-rust"><code class="lang-rust"><strong>// Макрос, который создаёт пустую функцию с заданным именем
</strong><strong>#[macro_export]
</strong>macro_rules! make_empty_func {
    ($func_name:ident) => {
        fn $func_name() {}
    }
}

make_empty_func!(function_1); // Нужна точка с запятой после вызова макроса
make_empty_func!{function_2}

fn main() {
    function_1();
    function_2();
}
</code></pre>



## Макрос vec

Теперь когда мы познакомились с декларативными макросами, становится помнятно почему `vec![]` оформлен именно в виде макроса, а не функции: функции не поддерживают переменное число аргументов.

Реальная имплементация макроса `vec![]` такова, что вызов `vec![1, 2, 3]` раскрывается в `<[_]>::into_vec(::alloc::boxed::box_new([1, 2, 3]))` (и мы пока что не готовы разбирать что это означает). Однако, в учебных целях, давайте напишем свою, более простую реализацию - классический учебный вариант, макрос vec2!.

```rust
#[macro_export]
macro_rules! vec2 {
    () => { Vec::new() };
    ( $( $x:expr),* ) => {
        {
            let mut _temp = Vec::new();
            $( _temp.push($x); )*
            _temp
        }
    }
}
```

Код вызова макроса

{% columns %}
{% column width="41.66666666666667%" %}
код

```rust
fn main() {
    let v = vec2![1,2,3];
    println!("{v:?}");
}
```
{% endcolumn %}

{% column width="58.33333333333333%" %}
раксрывается в

```rust
fn main() {
    let v = {
        let mut _temp = Vec::new();
        _temp.push(1);
        _temp.push(2);
        _temp.push(3);
        _temp
    };
    println!("{v:?}");
}
```
{% endcolumn %}
{% endcolumns %}
