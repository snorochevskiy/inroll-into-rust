---
description: Они же энамы
---

# Перечисления

Перечисления или просто "энамы" (enums) в Rust гораздо мощнее, чем в C, C++, Java других языках предыдущих поколений, и могут быть представлены в нескольких ипостасьях.

## Перечисление как в C

Если нам нужно перечисление как в C, то используется следующий синтаксис:

```rust
enum EnumName {
    Элемент1,
    Элемент2,
    …,
    ЭлементN
}
```

Например:

```rust
enum IpAddrKind {
    V4,
    V6,
}

fn main() {
    let ip_v4 = IpAddrKind::V4;
    let ip_v6 = IpAddrKind::V6;
}
```

Так же как и в Си, с элементами перечисления можно ассоциировать число, которое далее можно получить путём приведения элемента энама к `usize`:

```rust
enum HttpStatus {
    Ok = 200,
    NotModified = 304,
    NotFound = 404,
}

fn main() {
    println!("{}", HttpStatus::Ok as usize); // 200
}
```

## Перечисление как объединение типов

В отличии от C, в Rust перечисление может включать в себя не только значения, но различные типы (структуры и кортежи). При этом объект перечисления будет принадлежать одному из этих внутренних типов. То есть enum объявляет не возможные значения, а возможные типы, к одному из которых должен принадлежать объект энама.

Например, IP4 адрес кодируется 4 байтами, а IP6 адрес - 20 байтами, но IP4 адрес, как правило, записывают при помощи 4 чисел, а IP6 адрес, обычно, записывают строкой. Мы можем сделать перечисление, значение которого будет представлено либо кортежем из 4 байта, либо строкой:

```rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

fn main() {
    let home = IpAddr::V4(127, 0, 0, 1);
    let loopback = IpAddr::V6(String::from("::1"));
}
```

Теперь рассмотрим пример перечисления со структурами: объектом перечисления "фигура" может быть либо квадрат, либо прямоугольник.

```rust
enum Shape {
    Square { width: f32 },
    Rectangle { width: f32, height: f32 }
}
fn main() {
    let square = Shape::Square { width: 4.0 };
}
```

Одним из преимуществ использования энамов является то, что ими удобно пользоваться в `match` операторе, где компилятор заставит проверить все варианты перечисления.

```rust
enum Shape {
    Square { width: f32 },
    Rectangle { width: f32, height: f32 }
}

fn calc_area(shape: &Shape) -> f32 {
    match shape { // Нужно проверить и Square, и Rectangle
        Shape::Square { width } => width * width,
        Shape::Rectangle { width, height } => width * height,
    }
}

fn main() {
    let square = Shape::Square { width: 4.0 };
    println!("{}", calc_area(&square));
}
```

Для перечислений можно добавлять методы точно так же, как и для структур:

```rust
enum Shape {
    Square { width: f32 },
    Rectangle { width: f32, height: f32 }
}

impl Shape {
    fn calc_area(&self) -> f32 {
        match self {
            Shape::Square { width } => width * width,
            Shape::Rectangle { width, height } => width * height,
        }
    }
}

fn main() {
    let square = Shape::Square { width: 4.0 };
    println!("{}", square.calc_area());
}
```

{% hint style="info" %}
Перечисления в Rust основаны на, так называемых, ADT (Algebraic data type — алгебраические типы данных). Это раздел теории, которая рассматривает составные типы данных, как комбинации объекдинения и пересечения других тупов.
{% endhint %}

## if-let

Как мы уже сказали, оператор `match` заставит нас перебрать все возможные варианты перечисления. Одна если мы заинтересованы только в одном варианте, то мы можем использовать конструкцию **if-let** — версия оператора `if` с деструктурирующим шаблоном.

```rust
enum Shape {
    Square { width: f32 },
    Rectangle { width: f32, height: f32 }
}
fn main() {
    let s = Shape::Square { width: 4.0 };
    if let Shape::Square { width } = s {
        println!("This is square of width {width}");
    }
}
```

Разумеется, у `if-let`, как и у обычного `if` может быть `else` ветка.

## Лэйаут в памяти

При помощи энамов мы фактически можем хранить значения разных типов в массиве.

```rust
enum MyEnum {
    Byte(u8),
    UInt(u32),
}

fn main() {
    let arr = [MyEnum::Byte(1), MyEnum::UInt(5)];
}
```

Это достигается за счёт того, что под элементы энама резервируется такое количество памяти, которое необходимо для записи наибольшего из возможных ваниантов перечисления. То есть за гибкость приходится платиться потенциальным перерасходом памяти.

Так же, в начале блока? хранящего значение энама, содержится дискриминатор — число (может быть от `u8` до `u32`), которое позволяет узнать какой именно из вариантов паречисления хранится здесь.

Массив из примера выше выглядит в памяти примерно так:

<img src="../.gitbook/assets/file.excalidraw (3).svg" alt="" class="gitbook-drawing">

## Еще раз про перечисление "как в C"

Теперь когда мы знаем как устроены перечисления, мы можем еще раз взглянуть на самый первый пример из этой главы, и понять как он устроен.

```rust
enum IpAddrKind {
    V4,
    V6,
}
```

С семантической точки зрения, `V4` и `V6` - это никакие не значения, а просто синглтон структуры.

При этом, когда мы ассоциируем значение с элементом такой "C структуры", то мы просто задаём конкретные значения для дискриминаторов, ассоциированных с синглтон структурами.

```rust
enum HttpStatus {
    Ok = 200,          // дискриминатор = 200
    NotModified = 304, // дискриминатор = 304
    NotFound = 404,    // дискриминатор = 404
}
```
